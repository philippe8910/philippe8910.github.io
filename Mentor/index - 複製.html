<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <title>Hollow Slayer - Abyssal Ruins</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050508;
            /* æ›´æ·±é‚ƒçš„èƒŒæ™¯è‰² */
            font-family: 'Courier New', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            /* è®“ç•«å¸ƒé‚Šç·£ç™¼å…‰ï¼Œåƒæ˜¯åœ¨çœ‹ä¸€å€‹ç™¼å…‰çš„æ´ç©´ */
            box-shadow: 0 0 100px rgba(50, 50, 100, 0.3);
            background: linear-gradient(to bottom, #0d0d12 0%, #15151a 80%, #0a0a0d 100%);
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 800px;
            color: white;
            pointer-events: none;
            z-index: 10;
        }

        .bar-wrap {
            width: 100%;
            background: #222;
            height: 15px;
            border: 2px solid #444;
            margin-bottom: 5px;
            position: relative;
            box-shadow: 0 2px 5px black;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.1s;
        }

        #boss-hp {
            background: linear-gradient(to right, #900, #d00);
            width: 100%;
            box-shadow: 0 0 10px #d00;
        }

        #player-hp {
            background: linear-gradient(to right, #ccc, #fff);
            width: 100%;
            box-shadow: 0 0 10px #eee;
        }

        #heals {
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }

        .heal-orb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            background: transparent;
        }

        .heal-orb.filled {
            background: white;
            box-shadow: 0 0 15px white, inset 0 0 10px #aaf;
            border-color: white;
        }

        #msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 30px;
            color: white;
            text-shadow: 0 0 20px white;
            display: none;
            z-index: 20;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #777;
            font-size: 12px;
            z-index: 10;
            text-shadow: 1px 1px 2px black;
        }

        /* --- æ‰‹æ©Ÿç‰ˆé©é… CSS --- */
        @media (max-width: 1024px) {
            #ui {
                width: 95%;
                top: 10px;
            }

            canvas {
                width: 100vw;
                height: 100vh;
                object-fit: contain;
            }

            .controls {
                display: none;
            }
        }

        #rotate-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #050508;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
        }

        @media screen and (orientation: portrait) and (max-width: 1024px) {
            #rotate-warning {
                display: flex;
            }
        }

        #mobile-controls {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            user-select: none;
            -webkit-user-select: none;
        }

        @media (pointer: coarse) {
            #mobile-controls {
                display: block;
            }
        }

        .joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 160px;
            height: 160px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }

        #joystick-knob {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            left: 50px;
            top: 50px;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            pointer-events: none;
            transform: translate(0, 0);
            transition: 0.1s;
        }

        .action-zone {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            pointer-events: auto;
        }

        .m-btn {
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #555;
            border-radius: 50%;
            color: #ddd;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
            touch-action: manipulation;
        }

        .m-btn:active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.9);
            border-color: white;
        }

        #btn-atk {
            grid-column: 2;
            grid-row: 1;
            width: 90px;
            height: 90px;
            border-color: #ff5555;
            background: rgba(100, 0, 0, 0.2);
            font-size: 30px;
            margin-top: -20px;
        }

        #btn-jump {
            grid-column: 3;
            grid-row: 2;
            border-color: #5555ff;
        }

        #btn-dash {
            grid-column: 1;
            grid-row: 2;
            border-color: #55ff55;
        }

        #btn-heal {
            grid-column: 2;
            grid-row: 3;
            width: 60px;
            height: 60px;
            border-color: #ffff55;
            margin-top: 10px;
        }
    </style>
</head>

<body>

    <div id="ui">
        <div style="display:flex; justify-content:space-between; align-items:flex-end;">
            <div>
                <span style="font-size: 20px; text-shadow: 0 0 5px white;">VESSEL</span>
                <div id="heals">
                    <div class="heal-orb filled"></div>
                    <div class="heal-orb filled"></div>
                    <div class="heal-orb filled"></div>
                </div>
            </div>
            <span style="font-size: 24px; color: #ff4444; text-shadow: 0 0 15px red;">THE CORRUPTED KING</span>
        </div>
        <div class="bar-wrap" style="width: 30%; float:left; margin-top:5px;">
            <div id="player-hp" class="bar-fill"></div>
        </div>
        <div class="bar-wrap" style="width: 65%; float:right; margin-top:5px;">
            <div id="boss-hp" class="bar-fill"></div>
        </div>
    </div>

    <div id="msg">æŒ‰ä¸‹ SPACE æˆ– æ”»æ“Šéµ é€²å…¥æ·±æ·µ<br><span style="font-size:16px; color:#aaa;">(é»æ“Šç•«é¢é–‹å§‹)</span></div>
    <div class="controls">ç§»å‹•: WASD | è·³èº: K | æ”»æ“Š: J | è¡åˆº: L | å›è¡€(æŒ‰ä½): Q</div>

    <!-- æ‰‹æ©Ÿç‰ˆè­¦å‘Š -->
    <div id="rotate-warning">
        <div style="font-size: 40px; margin-bottom: 20px;">ğŸ“±</div>
        <h2>è«‹è½‰å‹•æ‚¨çš„è£ç½®</h2>
        <p>ç‚ºäº†æœ€ä½³é«”é©—ï¼Œè«‹ä½¿ç”¨æ©«å‘æ¨¡å¼éŠç©</p>
    </div>

    <!-- æ‰‹æ©Ÿç‰ˆæ§åˆ¶å™¨ -->
    <div id="mobile-controls">
        <div class="joystick-zone" id="joystick">
            <div id="joystick-knob"></div>
        </div>
        <div class="action-zone">
            <div class="m-btn" id="btn-dash">â†</div>
            <div class="m-btn" id="btn-atk">âš”</div>
            <div class="m-btn" id="btn-jump">â‡ª</div>
            <div class="m-btn" id="btn-heal">+</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1000;
        canvas.height = 600;

        // --- éŠæˆ²å¸¸æ•¸èª¿æ•´ ---
        const WORLD_WIDTH = 4000;
        const GROUND_Y = 550;

        // éŠæˆ²ç‹€æ…‹èˆ‡ç›¸æ©Ÿ
        let camera = { x: 0, y: 0 };
        let bossActive = false;

        // ç‰©ä»¶é™£åˆ—
        let particles = [], projectiles = [], slashes = [];
        let platforms = [], dummies = [], spikes = [], texts = [];
        let screenShake = 0, hitStop = 0;
        let frame = 0, gameRunning = false, gameOver = false;

        const keys = { left: false, right: false, up: false, atk: false, dash: false, heal: false };

        // --- éµç›¤è¼¸å…¥ ---
        document.addEventListener('keydown', e => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
            if (e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'KeyK') { if (!keys.up) player.jump(); keys.up = true; }
            if (e.code === 'KeyJ') {
                if (!gameRunning) {
                    if (gameOver) resetGame(); else startGame();
                } else {
                    if (!keys.atk) player.attack();
                }
                keys.atk = true;
            }
            if (e.code === 'KeyL' || e.code === 'ShiftLeft') { if (!keys.dash) player.dashMove(); keys.dash = true; }
            if (e.code === 'KeyQ') keys.heal = true;
            if (e.code === 'Space' && gameOver) resetGame();
            if (e.code === 'Space' && !gameRunning) startGame();
        });
        document.addEventListener('keyup', e => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
            if (e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'KeyK') keys.up = false;
            if (e.code === 'KeyJ') keys.atk = false;
            if (e.code === 'KeyL' || e.code === 'ShiftLeft') keys.dash = false;
            if (e.code === 'KeyQ') keys.heal = false;
        });

        // é»æ“Šç•«é¢ä¹Ÿå¯é–‹å§‹éŠæˆ² (é©é…æ‰‹æ©Ÿ)
        document.addEventListener('click', () => {
            if (!gameRunning && !gameOver) startGame();
        });

        function startGame() {
            gameRunning = true;
            document.getElementById('msg').style.display = 'none';

            // å˜—è©¦é€²å…¥å…¨è¢å¹•
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(err => { });
            }
            loop();
        }

        // --- è™›æ“¬æ–æ¡¿é‚è¼¯ ---
        const joystick = document.getElementById('joystick');
        const knob = document.getElementById('joystick-knob');
        let touchId = null;
        let joyStartX = 0, joyStartY = 0;

        joystick.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            touchId = touch.identifier;
            joyStartX = touch.clientX;
            joyStartY = touch.clientY;
            knob.style.transition = '0s';
        }, { passive: false });

        joystick.addEventListener('touchmove', e => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === touchId) {
                    const touch = e.changedTouches[i];
                    let dx = touch.clientX - joyStartX;
                    let dy = touch.clientY - joyStartY;
                    const dist = Math.min(Math.sqrt(dx * dx + dy * dy), 60); // é™åˆ¶ç§»å‹•åŠå¾‘
                    const angle = Math.atan2(dy, dx);

                    const moveX = Math.cos(angle) * dist;
                    const moveY = Math.sin(angle) * dist;

                    knob.style.transform = `translate(${moveX}px, ${moveY}px)`;

                    // åˆ¤æ–·æ–¹å‘
                    keys.left = dx < -20;
                    keys.right = dx > 20;

                    // å‘ä¸Šæ¨åˆ¤å®šç‚ºè·³èº (é¸æ“‡æ€§)
                    // if(dy < -40) { if(!keys.up) player.jump(); keys.up = true; } else { keys.up = false; }
                }
            }
        }, { passive: false });

        joystick.addEventListener('touchend', e => {
            e.preventDefault();
            touchId = null;
            knob.style.transition = '0.2s';
            knob.style.transform = `translate(0px, 0px)`;
            keys.left = false;
            keys.right = false;
            keys.up = false;
        });

        // --- è™›æ“¬æŒ‰éˆ•é‚è¼¯ ---
        const setupBtn = (id, keyName, autoRepeat = false, actionFunc = null) => {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', e => {
                e.preventDefault();
                if (actionFunc) actionFunc();
                if (!keys[keyName] && actionFunc && keyName === 'atk') { /* attack logic in actionFunc */ }
                // è‹¥ç‚ºå–®æ¬¡è§¸ç™¼ (å¦‚ Jump)ï¼Œé‚è¼¯éœ€å¾®èª¿ã€‚é€™è£¡çµ±ä¸€æŒ‰ä¸‹ç‚º true
                keys[keyName] = true;
                btn.style.background = 'rgba(255,255,255,0.4)';
            }, { passive: false });
            btn.addEventListener('touchend', e => {
                e.preventDefault();
                keys[keyName] = false;
                btn.style.background = '';
            });
        };

        setupBtn('btn-jump', 'up', false, () => player.jump());
        setupBtn('btn-atk', 'atk', false, () => {
            if (!gameRunning) {
                if (gameOver) resetGame(); else startGame();
            } else {
                player.attack();
            }
        });
        setupBtn('btn-dash', 'dash', false, () => player.dashMove());
        setupBtn('btn-heal', 'heal', true); // Heal åƒ…éœ€åµæ¸¬æŒ‰ä½



        // --- å…¨æ–°è¨­è¨ˆçš„å ´æ™¯é¡åˆ¥ (æ”¯æ´æ²å‹•) ---
        class Background {
            constructor() {
                // 1. é æ™¯ (è¦–å·®ä¿‚æ•¸ 0.2)
                this.distantRuins = [];
                for (let i = 0; i < 30; i++) { // å¢åŠ æ•¸é‡è¦†è“‹é•·åœ°åœ–
                    this.distantRuins.push({
                        x: i * 150 - 50,
                        w: 80 + Math.random() * 60,
                        h: 200 + Math.random() * 150,
                        offsetY: Math.random() * 20
                    });
                }

                // 2. ä¸­æ™¯ (è¦–å·®ä¿‚æ•¸ 0.5)
                this.pillars = [];
                for (let i = 0; i < 20; i++) {
                    this.pillars.push({ x: i * 280 + 50, w: 100 + Math.random() * 40, cracks: Math.random() > 0.5 });
                }

                // 3. å‰æ™¯ (è¦–å·®ä¿‚æ•¸ 1.2)
                this.foregroundObjects = [];
                for (let i = 0; i < 40; i++) {
                    this.foregroundObjects.push({
                        x: Math.random() * WORLD_WIDTH,
                        h: 50 + Math.random() * 150,
                        type: Math.random() > 0.7 ? 'chain' : 'vine'
                    });
                }

                // 4. ç²’å­ (è¦–çª—ç©ºé–“)
                this.dust = [];
                for (let i = 0; i < 30; i++) {
                    this.dust.push({
                        x: Math.random() * canvas.width, y: Math.random() * canvas.height,
                        size: Math.random() * 2.5, speed: Math.random() * 0.4 + 0.1, alpha: Math.random() * 0.5 + 0.2
                    });
                }
            }

            // ç¹ªè£½æœ€é çš„èƒŒæ™¯
            drawBack(ctx) {
                const slowMove = Math.sin(frame * 0.02) * 10;

                // è¦–å·®è¨ˆç®—: ç‰©ä»¶ä½ç½® - (ç›¸æ©Ÿä½ç½® * ä¿‚æ•¸)
                // 1. é æ™¯
                ctx.fillStyle = '#08080c';
                this.distantRuins.forEach(r => {
                    let rx = r.x - camera.x * 0.2;
                    if (rx > -200 && rx < canvas.width + 200) // åªç•«è¦–é‡å…§
                        ctx.fillRect(rx, 150 + r.offsetY + slowMove * 0.5, r.w, GROUND_Y);
                });

                // 2. ä¸­æ™¯
                this.pillars.forEach(p => {
                    let px = p.x - camera.x * 0.5;
                    if (px > -200 && px < canvas.width + 200) {
                        ctx.fillStyle = '#121218';
                        ctx.fillRect(px, 80 + slowMove, p.w, GROUND_Y - 80);
                        if (p.cracks) {
                            ctx.save();
                            ctx.shadowBlur = 15; ctx.shadowColor = '#4444ff';
                            ctx.strokeStyle = '#222255'; ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(px + 10, 100 + slowMove);
                            ctx.lineTo(px + p.w - 20, 250 + slowMove);
                            ctx.lineTo(px + 30, 400 + slowMove);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                });
            }

            // ç¹ªè£½å ´æ™¯ç‰©ä»¶ (å¹³å°ã€åœ°æ¿) -> é€™äº›è·Ÿéš¨ä¸–ç•Œåº§æ¨™ï¼Œä¸å¥—è¦–å·®ï¼Œä½†å— camera.x å½±éŸ¿ (åœ¨å¤–éƒ¨ transform ä¸‹ç¹ªè£½)
            drawWorld(ctx) {
                // åœ°æ¿
                ctx.fillStyle = '#0a0a0d';
                // ç”±æ–¼åœ°æ¿ç¾åœ¨æœ‰å‘æ´ï¼Œæˆ‘å€‘éœ€è¦ç¹ªè£½å…·é«”çš„å¹³å°
                platforms.forEach(p => {
                    ctx.fillStyle = p.type === 'wall' ? '#08080a' : '#0a0a0d';
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    // å¹³å°é‚Šç·£è£é£¾
                    ctx.fillStyle = '#1a1a22';
                    for (let i = p.x; i < p.x + p.w; i += 40) {
                        let h = Math.random() * 15;
                        ctx.beginPath(); ctx.moveTo(i, p.y); ctx.lineTo(i + 20, p.y - h); ctx.lineTo(i + 40, p.y); ctx.fill();
                    }
                    ctx.strokeStyle = '#222233'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(p.x, p.y + 1); ctx.lineTo(p.x + p.w, p.y + 1); ctx.stroke();
                });

                // å°–åˆº
                ctx.fillStyle = '#555';
                spikes.forEach(s => {
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y + s.h);
                    ctx.lineTo(s.x + s.w / 2, s.y);
                    ctx.lineTo(s.x + s.w, s.y + s.h);
                    ctx.fill();
                });

                // æ•™å­¸æ–‡å­—
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = '20px Courier New';
                ctx.textAlign = 'center';
                texts.forEach(t => {
                    ctx.fillText(t.str, t.x, t.y);
                });
                ctx.textAlign = 'left';
            }

            // ç¹ªè£½å‰æ™¯ (é®æ“‹ç‰©å’Œæ°›åœ) - è¦–å·®ä¿‚æ•¸ 1.2
            drawFront(ctx) {
                const fasterMove = Math.sin(frame * 0.03) * 15;
                ctx.fillStyle = '#040406';
                this.foregroundObjects.forEach(o => {
                    let ox = o.x - camera.x * 1.2;
                    if (ox > -50 && ox < canvas.width + 50) {
                        let sway = Math.sin(frame * 0.05 + o.x) * 5;
                        if (o.type === 'vine') {
                            ctx.beginPath();
                            ctx.moveTo(ox, 0);
                            ctx.quadraticCurveTo(ox + sway, o.h / 2, ox, o.h + fasterMove);
                            ctx.lineTo(ox + 10, o.h + fasterMove);
                            ctx.quadraticCurveTo(ox + sway + 10, o.h / 2, ox + 10, 0);
                            ctx.fill();
                        } else {
                            ctx.fillRect(ox + sway, -20, 5, o.h + fasterMove);
                        }
                    }
                });

                // 4. å¡µåŸƒç²’å­ (å¢åŠ ç’°å¢ƒå…‰æ„Ÿ)
                this.dust.forEach(d => {
                    d.y -= d.speed;
                    if (d.y < 0) d.y = canvas.height;
                    ctx.globalAlpha = d.alpha;
                    ctx.fillStyle = '#aaaaff'; // å¸¶é»è—è‰²çš„å¡µåŸƒ
                    ctx.beginPath(); ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2); ctx.fill();
                });
                ctx.globalAlpha = 1;

                // 5. å¼·çƒˆçš„æš—è§’æ•ˆæœ (Vignette) - èšç„¦ä¸­å¿ƒ
                const grad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 250, canvas.width / 2, canvas.height / 2, 700);
                grad.addColorStop(0, 'transparent');
                grad.addColorStop(0.7, 'rgba(0,0,0,0.5)');
                grad.addColorStop(1, 'rgba(0,0,0,0.9)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // --- (ä»¥ä¸‹ç‚ºæ—¢æœ‰çš„éŠæˆ²é‚è¼¯é¡åˆ¥ï¼Œæœªåšå¤§å¹…ä¿®æ”¹ï¼Œåƒ…é…åˆå ´æ™¯èª¿æ•´é¡è‰²) ---
        class SlashAnim {
            constructor(x, y, facing) {
                this.x = x; this.y = y; this.facing = facing; this.life = 1.0; this.angle = facing === 1 ? -0.5 : 3.5;
            }
            update() { this.life -= 0.15; this.x += this.facing * 2; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.scale(this.facing, 1);
                ctx.beginPath(); ctx.arc(0, 0, 60, -0.5, 0.5 + (1 - this.life));
                ctx.lineWidth = 20 * this.life; ctx.strokeStyle = `rgba(255, 255, 255, ${this.life})`;
                ctx.shadowBlur = 20; ctx.shadowColor = 'cyan'; // æ”¹ç‚ºå†·è‰²èª¿åˆ€å…‰
                ctx.stroke(); ctx.restore();
            }
        }
        class Particle {
            constructor(x, y, color, speed, size) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random() - 0.5) * speed; this.vy = (Math.random() - 0.5) * speed;
                this.life = 1.0; this.size = size;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.04; this.size *= 0.95; }
            draw(ctx) {
                ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
                ctx.shadowBlur = 5; ctx.shadowColor = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1; ctx.shadowBlur = 0;
            }
        }
        class Player {
            constructor() {
                this.w = 30; this.h = 50; this.x = 100; this.y = GROUND_Y - 50; this.vx = 0; this.vy = 0; this.facing = 1;
                this.hp = 100; this.maxHp = 100; this.heals = 3; this.healTimer = 0; this.healTimeMax = 90;
                this.jumps = 0; this.dashing = false; this.dashTime = 0; this.dashCooldown = 0;
                this.atkCooldown = 0; this.invincible = 60; this.grounded = false; this.updateHealUI();
            }
            jump() { if (this.jumps < 2) { this.vy = -13; this.jumps++; spawnParticles(this.x + 15, this.y + 50, '#555', 5, 4); } }
            dashMove() { if (this.dashCooldown <= 0 && !this.dashing) { this.dashing = true; this.dashTime = 12; this.dashCooldown = 50; this.vx = this.facing * 22; this.vy = 0; spawnParticles(this.x, this.y + 25, 'cyan', 10, 3); } }
            attack() {
                if (this.atkCooldown <= 0) {
                    this.atkCooldown = 20;
                    slashes.push(new SlashAnim(this.facing === 1 ? this.x + 40 : this.x - 40, this.y + 25, this.facing));
                    const hitBox = { x: this.facing === 1 ? this.x : this.x - 70, y: this.y - 10, w: 100, h: 70 };

                    // æ”»æ“Š Boss
                    if (bossActive && checkRectCollide(hitBox, boss)) {
                        boss.takeDamage(12); this.vy = Math.min(this.vy, -3); hitStop = 4; screenShake = 4; spawnParticles(boss.x + boss.w / 2, boss.y + boss.h / 2, 'orange', 15, 5);
                    }
                    // æ”»æ“Š Dummy
                    dummies.forEach((d, i) => {
                        if (d.hp > 0 && checkRectCollide(hitBox, d)) {
                            d.hp -= 20; hitStop = 4; screenShake = 2; spawnParticles(d.x + d.w / 2, d.y + d.h / 2, 'wheat', 10, 3);
                            if (d.hp <= 0) spawnParticles(d.x + d.w / 2, d.y + d.h / 2, 'white', 20, 5);
                        }
                    });
                }
            }
            healLogic() {
                if (keys.heal && Math.abs(this.vx) < 1 && this.grounded && this.heals > 0 && this.hp < this.maxHp) {
                    this.healTimer++; if (frame % 5 === 0) spawnParticles(this.x + Math.random() * 30, this.y + Math.random() * 50, 'white', 2, 2);
                    if (this.healTimer >= this.healTimeMax) { this.hp = Math.min(this.hp + 34, this.maxHp); this.heals--; this.healTimer = 0; this.updateHealUI(); spawnParticles(this.x + 15, this.y + 25, 'white', 30, 5); screenShake = 5; }
                } else { this.healTimer = 0; }
            }
            updateHealUI() { document.querySelectorAll('.heal-orb').forEach((orb, i) => orb.classList.toggle('filled', i < this.heals)); document.getElementById('player-hp').style.width = (this.hp / this.maxHp * 100) + '%'; }
            takeDamage(amt) { if (this.dashing || this.invincible > 0) return; this.hp -= amt; this.invincible = 60; this.healTimer = 0; screenShake = 12; this.updateHealUI(); spawnParticles(this.x + 15, this.y + 25, 'red', 15, 6); if (this.hp <= 0) endGame(false); }
            update() {
                if (this.dashCooldown > 0) this.dashCooldown--; if (this.atkCooldown > 0) this.atkCooldown--; if (this.invincible > 0) this.invincible--; this.healLogic();

                if (this.dashing) {
                    this.dashTime--; this.x += this.vx;
                    if (this.dashTime <= 0) { this.dashing = false; this.vx = 0; }
                } else {
                    if (this.healTimer > 0) { this.vx = 0; }
                    else { if (keys.left) { this.vx = -6; this.facing = -1; } else if (keys.right) { this.vx = 6; this.facing = 1; } else { this.vx *= 0.8; } }
                    this.vy += 0.6; this.x += this.vx; this.y += this.vy;
                }

                // ç‰©ç†èˆ‡ç¢°æ’
                if (this.x < 0) this.x = 0;
                if (this.x > WORLD_WIDTH - this.w) this.x = WORLD_WIDTH - this.w;

                this.grounded = false;
                // æª¢æŸ¥å¹³å°ç¢°æ’
                platforms.forEach(p => {
                    // ç°¡å–® AABB ç¢°æ’: 
                    // 1. è…³åœ¨å¹³å°ä¸Š
                    // 2. ä¸Šä¸€å¹€åœ¨å¹³å°ä¹‹ä¸Š (é¿å…å¾ä¸‹å¾€ä¸Šè·³å¡ä½) -> ç°¡åŒ–ç‚º: ä¸‹è½ä¸­ä¸”è…³åº•éƒ¨æ¥è¿‘å¹³å°é ‚éƒ¨
                    if (this.vy >= 0 &&
                        this.x + this.w > p.x && this.x < p.x + p.w &&
                        this.y + this.h >= p.y && this.y + this.h <= p.y + 20) {
                        this.y = p.y - this.h;
                        this.vy = 0;
                        this.grounded = true;
                        this.jumps = 0;
                    }
                });

                // æ‰è½æ·±æ·µ
                if (this.y > canvas.height + 100) {
                    this.hp -= 20; this.updateHealUI();
                    this.x = 100; this.y = GROUND_Y - 100; this.vx = 0; this.vy = 0; // é‡ç”Ÿé»ï¼šå›åˆ°èµ·é» (ç°¡åŒ–)
                    if (this.x > 3300) { this.x = 3400; } // è‹¥åœ¨ BOSS æˆ°æ‰è½
                    screenShake = 10;
                    if (this.hp <= 0) endGame(false);
                }

                // å°–åˆºç¢°æ’
                spikes.forEach(s => {
                    if (checkRectCollide(this, s) && this.invincible <= 0) {
                        this.takeDamage(10);
                        this.vy = -10;
                        this.x -= this.facing * 50; // æ“Šé€€
                    }
                });
            }
            draw(ctx) {
                if (this.invincible > 0 && frame % 4 === 0) return;
                ctx.fillStyle = 'white'; ctx.shadowBlur = 20; ctx.shadowColor = 'white'; ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.fillStyle = 'black'; ctx.shadowBlur = 0; ctx.fillRect(this.facing === 1 ? this.x + 18 : this.x + 4, this.y + 10, 8, 20);
                if (this.healTimer > 0) { ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x + 15, this.y - 20, 10, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * (this.healTimer / this.healTimeMax))); ctx.stroke(); }
            }
        }
        class Dummy {
            constructor(x, y) { this.x = x; this.y = y; this.w = 40; this.h = 60; this.hp = 60; }
            draw(ctx) {
                if (this.hp <= 0) return;
                ctx.fillStyle = '#886644'; ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.strokeStyle = '#aa8866'; ctx.strokeRect(this.x, this.y, this.w, this.h);
                // çœ¼ç›
                ctx.fillStyle = 'black'; ctx.fillRect(this.x + 10, this.y + 15, 5, 5); ctx.fillRect(this.x + 25, this.y + 15, 5, 5);
            }
        }

        class Boss {
            constructor() { this.w = 90; this.h = 110; this.x = 3700; this.y = GROUND_Y - 110; this.hp = 1500; this.maxHp = 1500; this.state = 'IDLE'; this.timer = 0; this.moveIndex = 0; this.vx = 0; this.vy = 0; this.opacity = 1; }
            takeDamage(amt) { const dmg = this.state === 'TIRED' ? amt * 1.5 : amt; this.hp -= dmg; document.getElementById('boss-hp').style.width = (this.hp / this.maxHp * 100) + '%'; if (this.state === 'TIRED') spawnParticles(this.x + this.w / 2, this.y + this.h / 2, 'white', 5, 3); if (this.hp <= 0) endGame(true); }
            update() {
                if (!bossActive) return; // æ²’è§¸ç™¼ä¸å‹•
                this.x += this.vx; this.y += this.vy;
                // é™åˆ¶åœ¨ç«¶æŠ€å ´ç¯„åœ 3400 ~ 4000
                if (this.x < 3400) { this.x = 3400; this.vx = 0; } if (this.x > WORLD_WIDTH - this.w) { this.x = WORLD_WIDTH - this.w; this.vx = 0; }
                if (this.y + this.h < GROUND_Y) this.vy += 0.6; else { this.y = GROUND_Y - this.h; this.vy = 0; } this.timer--;
                // Boss é‚è¼¯ä¸è®Š... -> ä½¿ç”¨ WORLD_WIDTH ä¿®æ­£
                if (this.state === 'IDLE') { this.y += Math.sin(frame * 0.1) * 0.5; if (this.timer <= 0) { this.state = 'PREPARE'; this.timer = 50; this.moveIndex = Math.floor(Math.random() * 5); this.telegraph(); } }
                else if (this.state === 'PREPARE') { if (player.x < this.x) this.vx = -1; else this.vx = 1; if (this.timer <= 0) { this.vx = 0; this.state = 'ATTACK'; this.executeAttack(); } }
                else if (this.state === 'TIRED') { this.opacity = 0.5; if (this.timer <= 0) { this.state = 'IDLE'; this.opacity = 1; this.timer = 40; } }
            }
            telegraph() { spawnParticles(this.x + this.w / 2, this.y, 'red', 8, 5); }
            toTired(dur) { this.state = 'TIRED'; this.timer = dur; this.vx = 0; }
            // ä¿®æ­£ Attack çš„ç¯„åœèˆ‡ç”¢ç”Ÿä½ç½®
            executeAttack() { const m = this.moveIndex; if (m === 0) { this.vx = (player.x < this.x) ? -18 : 18; this.timer = 40; setTimeout(() => { this.toTired(80); }, 800); } else if (m === 1) { this.vy = -25; const t = setInterval(() => { this.x += (player.x - this.x) * 0.15; }, 20); setTimeout(() => { clearInterval(t); this.vy = 35; setTimeout(() => { screenShake = 25; projectiles.push(new Projectile(this.x, GROUND_Y - 40, -9, 0, 40, 40)); projectiles.push(new Projectile(this.x + this.w, GROUND_Y - 40, 9, 0, 40, 40)); this.toTired(100); }, 250); }, 700); } else if (m === 2) { for (let i = -2; i <= 2; i++) { let a = Math.atan2(player.y - this.y, player.x - this.x) + (i * 0.3); projectiles.push(new Projectile(this.x + this.w / 2, this.y + this.h / 2, Math.cos(a) * 10, Math.sin(a) * 10, 25, 25)); } this.timer = 20; setTimeout(() => { this.toTired(60); }, 300); } else if (m === 3) { let c = 0; const r = setInterval(() => { let rx = Math.random() * 600 + 3400; spawnParticles(rx, 50, 'purple', 1, 2); setTimeout(() => { projectiles.push(new Projectile(rx, 0, 0, 15, 20, 100, '#a020f0')); }, 400); c++; if (c > 8) { clearInterval(r); this.toTired(70); } }, 150); } else if (m === 4) { this.opacity = 0; spawnParticles(this.x, this.y, 'red', 20, 5); setTimeout(() => { this.opacity = 1; this.x = Math.max(3400, Math.min(WORLD_WIDTH - this.w, player.x + (player.facing * -100))); this.y = GROUND_Y - this.h; screenShake = 10; if (checkRectCollide(this, player)) player.takeDamage(20); this.toTired(90); }, 600); } }
            draw(ctx) {
                if (this.opacity === 0) return; ctx.save(); ctx.globalAlpha = this.opacity;
                if (this.state === 'PREPARE') { ctx.shadowBlur = 30; ctx.shadowColor = 'red'; ctx.fillStyle = '#ffaaaa'; } else if (this.state === 'TIRED') { ctx.shadowBlur = 5; ctx.shadowColor = 'gray'; ctx.fillStyle = '#550000'; } else { ctx.shadowBlur = 25; ctx.shadowColor = '#ff0000'; ctx.fillStyle = '#aa0000'; }
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.w, this.y); ctx.lineTo(this.x + this.w - 10, this.y + this.h); ctx.lineTo(this.x + 10, this.y + this.h); ctx.fill();
                ctx.fillStyle = (this.state === 'TIRED') ? '#555' : 'yellow'; ctx.shadowBlur = (this.state === 'TIRED') ? 0 : 10; ctx.shadowColor = 'yellow'; ctx.beginPath(); ctx.arc(this.x + 30, this.y + 40, 8, 0, Math.PI * 2); ctx.arc(this.x + this.w - 30, this.y + 40, 8, 0, Math.PI * 2); ctx.fill(); ctx.restore();
            }
        }
        class Projectile { constructor(x, y, vx, vy, w, h, c = 'orange') { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.w = w; this.h = h; this.color = c; this.active = true; } update() { this.x += this.vx; this.y += this.vy; if (this.y > canvas.height + 200) this.active = false; if (this.active && checkRectCollide(this, player)) { player.takeDamage(15); this.active = false; } } draw(ctx) { ctx.fillStyle = this.color; ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.beginPath(); ctx.arc(this.x + this.w / 2, this.y + this.h / 2, this.w / 2, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; } }

        function checkRectCollide(r1, r2) { return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y); }
        function spawnParticles(x, y, c, cnt, sz) { for (let i = 0; i < cnt; i++)particles.push(new Particle(x, y, c, 8, sz)); }
        function resetGame() {
            player = new Player(); boss = new Boss(); bg = new Background();
            projectiles = []; particles = []; slashes = [];
            gameOver = false; gameRunning = true; bossActive = false; camera.x = 0;
            document.getElementById('msg').style.display = 'none';
            document.getElementById('boss-hp').style.width = '100%';

            // --- é‡æ–°å»ºç«‹é—œå¡è³‡æ–™ ---
            platforms = [
                // èµ·å§‹å¹³åœ°
                { x: 0, y: GROUND_Y, w: 1000, h: 50, type: 'ground' },
                // è·³èºæ•™å­¸
                { x: 1100, y: GROUND_Y - 70, w: 100, h: 120, type: 'wall' },
                { x: 1200, y: GROUND_Y, w: 300, h: 50, type: 'ground' },
                { x: 1600, y: GROUND_Y - 120, w: 100, h: 170, type: 'wall' },
                // è¡åˆºæ•™å­¸ (å¿…é ˆè¡éçš„æ·±æ·µ)
                { x: 1800, y: GROUND_Y, w: 300, h: 50, type: 'ground' },
                // æ”»æ“Šæ•™å­¸å¹³å°
                { x: 2300, y: GROUND_Y, w: 600, h: 50, type: 'ground' },
                // å°–åˆºé™·é˜±
                { x: 3000, y: GROUND_Y, w: 200, h: 50, type: 'ground' },
                // Boss æˆ°å ´
                { x: 3300, y: GROUND_Y, w: 700, h: 50, type: 'ground' }
            ];

            dummies = [
                new Dummy(2600, GROUND_Y - 60)
            ];

            spikes = [
                { x: 3050, y: GROUND_Y - 30, w: 100, h: 30 }
            ];

            texts = [
                { str: "AD / æ–æ¡¿ ç§»å‹•", x: 200, y: 400 },
                { str: "K / â‡ª è·³èº", x: 1300, y: 350 },
                { str: "L / â† è¡åˆº", x: 1950, y: 400 },
                { str: "J / âš” æ”»æ“Š", x: 2450, y: 400 },
                { str: "æŒ‰ä½ Q / + å›è¡€", x: 2850, y: 300 },
                { str: "âš  å±éšª âš ", x: 3100, y: 250 },
            ];

            loop();
        }
        function endGame(win) { gameRunning = false; gameOver = true; const msg = document.getElementById('msg'); msg.style.display = 'block'; msg.innerHTML = win ? "<span style='color:gold'>å¤ç‹å·²é€</span><br><span style='font-size:20px'>æŒ‰ æ”»æ“Šéµ å†æˆ°</span>" : "<span style='color:red'>å®¹å™¨ç ´ç¢</span><br><span style='font-size:20px'>æŒ‰ æ”»æ“Šéµ é‡è©¦</span>"; }

        let player = new Player(), boss = new Boss(), bg = new Background();

        function loop() {
            if (!gameRunning) return; requestAnimationFrame(loop);
            if (hitStop > 0) { hitStop--; return; } frame++;
            let sx = 0, sy = 0; if (screenShake > 0) { sx = (Math.random() - 0.5) * screenShake; sy = (Math.random() - 0.5) * screenShake; screenShake *= 0.9; }

            // --- ç›¸æ©Ÿé‚è¼¯ ---
            let targetCamX = player.x - 400; // ç©å®¶åœ¨å·¦å´ 40% ä½ç½®
            if (bossActive) targetCamX = 3300; // Boss æˆ¿å›ºå®šç›¸æ©Ÿ
            // é‚Šç•Œé™åˆ¶
            targetCamX = Math.max(0, Math.min(WORLD_WIDTH - canvas.width, targetCamX));
            camera.x += (targetCamX - camera.x) * 0.1; // å¹³æ»‘è·Ÿéš¨

            // è§¸ç™¼ Boss
            if (!bossActive && player.x > 3350) {
                bossActive = true;
                document.getElementById('ui').style.opacity = 1; // Show UI
            }

            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height); // æ¸…é™¤è¢å¹•

            // 1. èƒŒæ™¯ (ä½¿ç”¨è¦–å·®ï¼Œå…§éƒ¨è‡ªå·±è™•ç† camera åç§»)
            bg.drawBack(ctx);

            // 2. éŠæˆ²ä¸–ç•Œå±¤ (è·Ÿéš¨ç›¸æ©Ÿ)
            ctx.save();
            ctx.translate(-camera.x + sx, 0 + sy); // å¥—ç”¨ç›¸æ©Ÿ + éœ‡å‹•

            bg.drawWorld(ctx); // ç¹ªè£½åœ°å¡Šã€æ–‡å­—ã€é™·é˜±

            dummies.forEach(d => d.draw(ctx));
            particles.forEach(p => p.update()); particles = particles.filter(p => p.life > 0); particles.forEach(p => p.draw(ctx));
            player.update(); player.draw(ctx);
            boss.update(); boss.draw(ctx);

            if (bossActive && boss.state !== 'TIRED' && checkRectCollide(player, boss)) player.takeDamage(10);

            projectiles.forEach(p => p.update()); projectiles = projectiles.filter(p => p.active); projectiles.forEach(p => p.draw(ctx));
            slashes.forEach(s => s.update()); slashes = slashes.filter(s => s.life > 0); slashes.forEach(s => s.draw(ctx));

            // 3. å‰æ™¯ (è¦–å·®)
            ctx.restore(); // æ¢å¾©ä¸–ç•Œå±¤ (å–æ¶ˆ camera åç§»ï¼Œä½†èƒŒæ™¯ drawFront è‡ªå·±æœƒç®—)
            bg.drawFront(ctx);

            ctx.restore(); // æ¢å¾©æœ€å¤–å±¤ (é‡å° UI)
        }
        ctx.fillStyle = 'white'; ctx.font = '20px Courier New';
        ctx.fillText("æŒ‰ æ”»æ“Šéµ(âš”) é–‹å§‹", canvas.width / 2 - 100, 300);
    </script>
</body>

</html>