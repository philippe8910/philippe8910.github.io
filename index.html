<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Hollow Slayer - Abyssal Ruins</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background: #050508; /* 更深邃的背景色 */
            font-family: 'Courier New', sans-serif;
            display: flex; justify-content: center; align-items: center; height: 100vh;
        }
        canvas { 
            /* 讓畫布邊緣發光，像是在看一個發光的洞穴 */
            box-shadow: 0 0 100px rgba(50, 50, 100, 0.3);
            background: linear-gradient(to bottom, #0d0d12 0%, #15151a 80%, #0a0a0d 100%);
        }
        #ui {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 800px; color: white; pointer-events: none; z-index: 10;
        }
        .bar-wrap { width: 100%; background: #222; height: 15px; border: 2px solid #444; margin-bottom: 5px; position: relative; box-shadow: 0 2px 5px black;}
        .bar-fill { height: 100%; transition: width 0.1s; }
        #boss-hp { background: linear-gradient(to right, #900, #d00); width: 100%; box-shadow: 0 0 10px #d00; }
        #player-hp { background: linear-gradient(to right, #ccc, #fff); width: 100%; box-shadow: 0 0 10px #eee; }
        
        #heals { display: flex; gap: 10px; margin-top: 5px; }
        .heal-orb { 
            width: 20px; height: 20px; border-radius: 50%; 
            border: 2px solid rgba(255,255,255,0.5); background: transparent;
        }
        .heal-orb.filled { background: white; box-shadow: 0 0 15px white, inset 0 0 10px #aaf; border-color: white;}

        #msg { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            text-align: center; font-size: 30px; color: white; text-shadow: 0 0 20px white;
            display: none; z-index: 20;
        }
        .controls { position: absolute; bottom: 10px; left: 10px; color: #777; font-size: 12px; z-index: 10; text-shadow: 1px 1px 2px black;}
    </style>
</head>
<body>

<div id="ui">
    <div style="display:flex; justify-content:space-between; align-items:flex-end;">
        <div>
            <span style="font-size: 20px; text-shadow: 0 0 5px white;">VESSEL</span>
            <div id="heals">
                <div class="heal-orb filled"></div>
                <div class="heal-orb filled"></div>
                <div class="heal-orb filled"></div>
            </div>
        </div>
        <span style="font-size: 24px; color: #ff4444; text-shadow: 0 0 15px red;">THE CORRUPTED KING</span>
    </div>
    <div class="bar-wrap" style="width: 30%; float:left; margin-top:5px;"><div id="player-hp" class="bar-fill"></div></div>
    <div class="bar-wrap" style="width: 65%; float:right; margin-top:5px;"><div id="boss-hp" class="bar-fill"></div></div>
</div>

<div id="msg">按下 SPACE 進入深淵</div>
<div class="controls">移動: WASD | 跳躍: K | 攻擊: J | 衝刺: L | 回血(按住): Q</div>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 1000;
    canvas.height = 600;

    let gameRunning = false, gameOver = false;
    let frame = 0;
    let particles = [], projectiles = [], slashes = [];
    let screenShake = 0, hitStop = 0; 
    const GROUND_Y = 550;

    const keys = { left:false, right:false, up:false, atk:false, dash:false, heal:false };
    document.addEventListener('keydown', e => {
        if(e.code==='ArrowLeft' || e.code==='KeyA') keys.left = true;
        if(e.code==='ArrowRight' || e.code==='KeyD') keys.right = true;
        if(e.code==='ArrowUp' || e.code==='KeyW' || e.code==='KeyK') { if(!keys.up) player.jump(); keys.up = true; }
        if(e.code==='KeyJ') { if(!keys.atk) player.attack(); keys.atk = true; }
        if(e.code==='KeyL' || e.code==='ShiftLeft') { if(!keys.dash) player.dashMove(); keys.dash = true; }
        if(e.code==='KeyQ') keys.heal = true;
        if(e.code==='Space' && gameOver) resetGame();
        if(e.code==='Space' && !gameRunning) { gameRunning=true; document.getElementById('msg').style.display='none'; loop(); }
    });
    document.addEventListener('keyup', e => {
        if(e.code==='ArrowLeft' || e.code==='KeyA') keys.left = false;
        if(e.code==='ArrowRight' || e.code==='KeyD') keys.right = false;
        if(e.code==='ArrowUp' || e.code==='KeyW' || e.code==='KeyK') keys.up = false;
        if(e.code==='KeyJ') keys.atk = false;
        if(e.code==='KeyL' || e.code==='ShiftLeft') keys.dash = false;
        if(e.code==='KeyQ') keys.heal = false;
    });

    // --- 全新設計的場景類別 ---
    class Background {
        constructor() {
            // 1. 遠景層 (古代遺跡輪廓)
            this.distantRuins = [];
            for(let i=0; i<8; i++) {
                this.distantRuins.push({
                    x: i * 150 - 50,
                    w: 80 + Math.random()*60,
                    h: 200 + Math.random()*150,
                    offsetY: Math.random() * 20 // 隨機垂直偏移
                });
            }

            // 2. 中景層 (帶有發光裂縫的柱子)
            this.pillars = [];
            for(let i=0; i<5; i++) {
                this.pillars.push({x: i*280 + 50, w: 100 + Math.random()*40, cracks: Math.random() > 0.5});
            }
            
            // 3. 前景層 (懸掛的藤蔓/鎖鏈)
            this.foregroundObjects = [];
            for(let i=0; i<12; i++) {
                this.foregroundObjects.push({
                    x: Math.random() * canvas.width,
                    h: 50 + Math.random() * 150,
                    type: Math.random() > 0.7 ? 'chain' : 'vine'
                });
            }

            // 4. 環境粒子 (塵埃)
            this.dust = [];
            for(let i=0; i<30; i++) {
                this.dust.push({
                    x: Math.random()*canvas.width, y: Math.random()*canvas.height, 
                    size: Math.random()*2.5, speed: Math.random()*0.4 + 0.1, alpha: Math.random()*0.5+0.2
                });
            }
        }

        // 繪製最遠的背景
        drawBack(ctx) {
            const slowMove = Math.sin(frame * 0.02) * 10; // 極慢的呼吸移動

            // 1. 遠景廢墟 (最深色)
            ctx.fillStyle = '#08080c';
            this.distantRuins.forEach(r => {
                ctx.fillRect(r.x, 150 + r.offsetY + slowMove * 0.5, r.w, GROUND_Y);
            });

            // 2. 中景柱子 (深灰色 + 發光裂縫)
            this.pillars.forEach(p => {
                // 柱子本體
                ctx.fillStyle = '#121218';
                ctx.fillRect(p.x, 80 + slowMove, p.w, GROUND_Y - 80);
                
                // 裂縫發光效果
                if(p.cracks) {
                    ctx.save();
                    ctx.shadowBlur = 15; ctx.shadowColor = '#4444ff'; // 藍紫色微光
                    ctx.strokeStyle = '#222255'; ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(p.x + 10, 100 + slowMove);
                    ctx.lineTo(p.x + p.w - 20, 250 + slowMove);
                    ctx.lineTo(p.x + 30, 400 + slowMove);
                    ctx.stroke();
                    ctx.restore();
                }
            });
        }

        // 繪製地板
        drawFloor(ctx) {
            // 地板本體
            ctx.fillStyle = '#0a0a0d';
            ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height-GROUND_Y);
            
            // 地板邊緣的碎石質感
            ctx.fillStyle = '#1a1a22';
            for(let i=0; i<canvas.width; i+=40) {
                let height = Math.random() * 15;
                ctx.beginPath();
                ctx.moveTo(i, GROUND_Y);
                ctx.lineTo(i+20, GROUND_Y - height);
                ctx.lineTo(i+40, GROUND_Y);
                ctx.fill();
            }
            
            // 地面邊緣光
            ctx.strokeStyle = '#222233'; ctx.lineWidth=2;
            ctx.beginPath(); ctx.moveTo(0, GROUND_Y+1); ctx.lineTo(canvas.width, GROUND_Y+1); ctx.stroke();
        }

        // 繪製前景 (遮擋物和氛圍)
        drawFront(ctx) {
            const fasterMove = Math.sin(frame * 0.03) * 15;

            // 3. 前景懸掛物 (幾乎黑色，移動較快造成深度感)
            ctx.fillStyle = '#040406';
            this.foregroundObjects.forEach(o => {
                let sway = Math.sin(frame * 0.05 + o.x) * 5; // 輕微擺動
                if(o.type === 'vine') {
                    ctx.beginPath();
                    ctx.moveTo(o.x, 0);
                    ctx.quadraticCurveTo(o.x + sway, o.h/2, o.x, o.h + fasterMove);
                    ctx.lineTo(o.x + 10, o.h + fasterMove);
                     ctx.quadraticCurveTo(o.x + sway + 10, o.h/2, o.x + 10, 0);
                    ctx.fill();
                } else {
                    ctx.fillRect(o.x + sway, -20, 5, o.h + fasterMove); // 鎖鏈
                }
            });

            // 4. 塵埃粒子 (增加環境光感)
            this.dust.forEach(d => {
                d.y -= d.speed;
                if(d.y < 0) d.y = canvas.height;
                ctx.globalAlpha = d.alpha;
                ctx.fillStyle = '#aaaaff'; // 帶點藍色的塵埃
                ctx.beginPath(); ctx.arc(d.x, d.y, d.size, 0, Math.PI*2); ctx.fill();
            });
            ctx.globalAlpha = 1;

            // 5. 強烈的暗角效果 (Vignette) - 聚焦中心
            const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 250, canvas.width/2, canvas.height/2, 700);
            grad.addColorStop(0, 'transparent');
            grad.addColorStop(0.7, 'rgba(0,0,0,0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0.9)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,canvas.width, canvas.height);
        }
    }

    // --- (以下為既有的遊戲邏輯類別，未做大幅修改，僅配合場景調整顏色) ---
    class SlashAnim {
        constructor(x, y, facing) {
            this.x = x; this.y = y; this.facing = facing; this.life = 1.0; this.angle = facing === 1 ? -0.5 : 3.5;
        }
        update() { this.life -= 0.15; this.x += this.facing * 2; }
        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y); ctx.scale(this.facing, 1);
            ctx.beginPath(); ctx.arc(0, 0, 60, -0.5, 0.5 + (1-this.life));
            ctx.lineWidth = 20 * this.life; ctx.strokeStyle = `rgba(255, 255, 255, ${this.life})`;
            ctx.shadowBlur = 20; ctx.shadowColor = 'cyan'; // 改為冷色調刀光
            ctx.stroke(); ctx.restore();
        }
    }
    class Particle {
        constructor(x, y, color, speed, size) {
            this.x = x; this.y = y; this.color = color;
            this.vx = (Math.random()-0.5)*speed; this.vy = (Math.random()-0.5)*speed;
            this.life = 1.0; this.size = size;
        }
        update() { this.x += this.vx; this.y += this.vy; this.life -= 0.04; this.size *= 0.95; }
        draw(ctx) {
            ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
            ctx.shadowBlur = 5; ctx.shadowColor = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1; ctx.shadowBlur = 0;
        }
    }
    class Player {
        constructor() {
            this.w = 30; this.h = 50; this.x = 100; this.y = GROUND_Y - 50; this.vx = 0; this.vy = 0; this.facing = 1;
            this.hp = 100; this.maxHp = 100; this.heals = 3; this.healTimer = 0; this.healTimeMax = 90;
            this.jumps = 0; this.dashing = false; this.dashTime = 0; this.dashCooldown = 0;
            this.atkCooldown = 0; this.invincible = 0; this.updateHealUI();
        }
        jump() { if (this.jumps < 2) { this.vy = -13; this.jumps++; spawnParticles(this.x+15, this.y+50, '#555', 5, 4); }}
        dashMove() { if (this.dashCooldown <= 0 && !this.dashing) { this.dashing = true; this.dashTime = 12; this.dashCooldown = 50; this.vx = this.facing * 22; this.vy = 0; spawnParticles(this.x, this.y+25, 'cyan', 10, 3); }}
        attack() { if (this.atkCooldown <= 0) { this.atkCooldown = 20; slashes.push(new SlashAnim(this.facing===1?this.x+40:this.x-40, this.y+25, this.facing)); const hitBox = {x: this.facing===1?this.x:this.x-70, y:this.y-10, w:100, h:70}; if (checkRectCollide(hitBox, boss)) { boss.takeDamage(12); this.vy = Math.min(this.vy, -3); hitStop = 4; screenShake = 4; spawnParticles(boss.x+boss.w/2, boss.y+boss.h/2, 'orange', 15, 5); }}}
        healLogic() {
            if(keys.heal && Math.abs(this.vx)<1 && this.grounded && this.heals>0 && this.hp<this.maxHp) {
                this.healTimer++; if(frame%5===0) spawnParticles(this.x+Math.random()*30, this.y+Math.random()*50, 'white', 2, 2);
                if(this.healTimer >= this.healTimeMax) { this.hp = Math.min(this.hp+34, this.maxHp); this.heals--; this.healTimer = 0; this.updateHealUI(); spawnParticles(this.x+15, this.y+25, 'white', 30, 5); screenShake = 5; }
            } else { this.healTimer = 0; }
        }
        updateHealUI() { document.querySelectorAll('.heal-orb').forEach((orb,i)=>orb.classList.toggle('filled', i<this.heals)); document.getElementById('player-hp').style.width = (this.hp/this.maxHp*100)+'%'; }
        takeDamage(amt) { if(this.dashing||this.invincible>0)return; this.hp-=amt; this.invincible=60; this.healTimer=0; screenShake=12; this.updateHealUI(); spawnParticles(this.x+15, this.y+25, 'red', 15, 6); if(this.hp<=0) endGame(false); }
        update() { if(this.dashCooldown>0)this.dashCooldown--; if(this.atkCooldown>0)this.atkCooldown--; if(this.invincible>0)this.invincible--; this.healLogic(); if(this.dashing){this.dashTime--;this.x+=this.vx;if(this.dashTime<=0){this.dashing=false;this.vx=0;}return;} if(this.healTimer>0){this.vx=0;}else{if(keys.left){this.vx=-6;this.facing=-1;}else if(keys.right){this.vx=6;this.facing=1;}else{this.vx*=0.8;}} this.vy+=0.6; this.x+=this.vx; this.y+=this.vy; if(this.y+this.h>GROUND_Y){this.y=GROUND_Y-this.h;this.vy=0;this.grounded=true;this.jumps=0;}else{this.grounded=false;} if(this.x<0)this.x=0;if(this.x>canvas.width-this.w)this.x=canvas.width-this.w; }
        draw(ctx) {
            if(this.invincible>0&&frame%4===0)return;
            ctx.fillStyle = 'white'; ctx.shadowBlur = 20; ctx.shadowColor = 'white'; ctx.fillRect(this.x, this.y, this.w, this.h);
            ctx.fillStyle = 'black'; ctx.shadowBlur = 0; ctx.fillRect(this.facing===1?this.x+18:this.x+4, this.y+10, 8, 20);
            if(this.healTimer>0) { ctx.strokeStyle='white'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(this.x+15, this.y-20, 10, -Math.PI/2, -Math.PI/2+(Math.PI*2*(this.healTimer/this.healTimeMax))); ctx.stroke(); }
        }
    }
    class Boss {
        constructor() { this.w=90; this.h=110; this.x=800; this.y=GROUND_Y-110; this.hp=1500; this.maxHp=1500; this.state='IDLE'; this.timer=0; this.moveIndex=0; this.vx=0; this.vy=0; this.opacity=1; }
        takeDamage(amt) { const dmg=this.state==='TIRED'?amt*1.5:amt; this.hp-=dmg; document.getElementById('boss-hp').style.width=(this.hp/this.maxHp*100)+'%'; if(this.state==='TIRED')spawnParticles(this.x+this.w/2,this.y+this.h/2,'white',5,3); if(this.hp<=0)endGame(true); }
        update() {
            this.x+=this.vx; this.y+=this.vy; if(this.x<0){this.x=0;this.vx=0;}if(this.x>canvas.width-this.w){this.x=canvas.width-this.w;this.vx=0;} if(this.y+this.h<GROUND_Y)this.vy+=0.6;else{this.y=GROUND_Y-this.h;this.vy=0;} this.timer--;
            if(this.state==='IDLE') { this.y+=Math.sin(frame*0.1)*0.5; if(this.timer<=0){this.state='PREPARE';this.timer=50;this.moveIndex=Math.floor(Math.random()*5);this.telegraph();}}
            else if(this.state==='PREPARE'){ if(player.x<this.x)this.vx=-1;else this.vx=1; if(this.timer<=0){this.vx=0;this.state='ATTACK';this.executeAttack();}}
            else if(this.state==='TIRED'){ this.opacity=0.5; if(this.timer<=0){this.state='IDLE';this.opacity=1;this.timer=40;}}
        }
        telegraph() { spawnParticles(this.x+this.w/2, this.y, 'red', 8, 5); }
        toTired(dur) { this.state='TIRED'; this.timer=dur; this.vx=0; }
        executeAttack() { const m=this.moveIndex; if(m===0){this.vx=(player.x<this.x)?-18:18;this.timer=40;setTimeout(()=>{this.toTired(80);},800);}else if(m===1){this.vy=-25;const t=setInterval(()=>{this.x+=(player.x-this.x)*0.15;},20);setTimeout(()=>{clearInterval(t);this.vy=35;setTimeout(()=>{screenShake=25;projectiles.push(new Projectile(this.x,GROUND_Y-40,-9,0,40,40));projectiles.push(new Projectile(this.x+this.w,GROUND_Y-40,9,0,40,40));this.toTired(100);},250);},700);}else if(m===2){for(let i=-2;i<=2;i++){let a=Math.atan2(player.y-this.y,player.x-this.x)+(i*0.3);projectiles.push(new Projectile(this.x+this.w/2,this.y+this.h/2,Math.cos(a)*10,Math.sin(a)*10,25,25));}this.timer=20;setTimeout(()=>{this.toTired(60);},300);}else if(m===3){let c=0;const r=setInterval(()=>{let rx=Math.random()*canvas.width;spawnParticles(rx,50,'purple',1,2);setTimeout(()=>{projectiles.push(new Projectile(rx,0,0,15,20,100,'#a020f0'));},400);c++;if(c>8){clearInterval(r);this.toTired(70);}},150);}else if(m===4){this.opacity=0;spawnParticles(this.x,this.y,'red',20,5);setTimeout(()=>{this.opacity=1;this.x=Math.max(0,Math.min(canvas.width-this.w,player.x+(player.facing*-100)));this.y=GROUND_Y-this.h;screenShake=10;if(checkRectCollide(this,player))player.takeDamage(20);this.toTired(90);},600);}}
        draw(ctx) {
            if(this.opacity===0)return; ctx.save(); ctx.globalAlpha=this.opacity;
            if(this.state==='PREPARE'){ctx.shadowBlur=30;ctx.shadowColor='red';ctx.fillStyle='#ffaaaa';}else if(this.state==='TIRED'){ctx.shadowBlur=5;ctx.shadowColor='gray';ctx.fillStyle='#550000';}else{ctx.shadowBlur=25;ctx.shadowColor='#ff0000';ctx.fillStyle='#aa0000';}
            ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(this.x+this.w,this.y); ctx.lineTo(this.x+this.w-10,this.y+this.h); ctx.lineTo(this.x+10,this.y+this.h); ctx.fill();
            ctx.fillStyle=(this.state==='TIRED')?'#555':'yellow'; ctx.shadowBlur=(this.state==='TIRED')?0:10; ctx.shadowColor='yellow'; ctx.beginPath(); ctx.arc(this.x+30,this.y+40,8,0,Math.PI*2); ctx.arc(this.x+this.w-30,this.y+40,8,0,Math.PI*2); ctx.fill(); ctx.restore();
        }
    }
    class Projectile { constructor(x,y,vx,vy,w,h,c='orange'){this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.w=w;this.h=h;this.color=c;this.active=true;} update(){this.x+=this.vx;this.y+=this.vy;if(this.x<-100||this.x>canvas.width+100||this.y>canvas.height)this.active=false;if(this.active&&checkRectCollide(this,player)){player.takeDamage(15);this.active=false;}} draw(ctx){ctx.fillStyle=this.color;ctx.shadowBlur=15;ctx.shadowColor=this.color;ctx.beginPath();ctx.arc(this.x+this.w/2,this.y+this.h/2,this.w/2,0,Math.PI*2);ctx.fill();ctx.shadowBlur=0;}}

    function checkRectCollide(r1,r2){return(r1.x<r2.x+r2.w&&r1.x+r1.w>r2.x&&r1.y<r2.y+r2.h&&r1.y+r1.h>r2.y);}
    function spawnParticles(x,y,c,cnt,sz){for(let i=0;i<cnt;i++)particles.push(new Particle(x,y,c,8,sz));}
    function resetGame(){player=new Player();boss=new Boss();projectiles=[];particles=[];slashes=[];gameOver=false;gameRunning=true;document.getElementById('msg').style.display='none';document.getElementById('boss-hp').style.width='100%';bg=new Background();loop();}
    function endGame(win){gameRunning=false;gameOver=true;const msg=document.getElementById('msg');msg.style.display='block';msg.innerHTML=win?"<span style='color:gold'>古王已逝</span><br><span style='font-size:20px'>按 SPACE 再戰</span>":"<span style='color:red'>容器破碎</span><br><span style='font-size:20px'>按 SPACE 重試</span>";}

    let player=new Player(), boss=new Boss(), bg=new Background();

    function loop() {
        if(!gameRunning)return; requestAnimationFrame(loop);
        if(hitStop>0){hitStop--;return;} frame++;
        let sx=0,sy=0; if(screenShake>0){sx=(Math.random()-0.5)*screenShake;sy=(Math.random()-0.5)*screenShake;screenShake*=0.9;}
        
        ctx.save(); ctx.translate(sx,sy);
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // 1. 繪製背景層 (後)
        bg.drawBack(ctx);
        // 2. 繪製地板層
        bg.drawFloor(ctx);

        particles.forEach(p=>p.update()); particles=particles.filter(p=>p.life>0); particles.forEach(p=>p.draw(ctx));
        player.update(); player.draw(ctx);
        boss.update(); boss.draw(ctx);
        if(boss.state!=='TIRED'&&checkRectCollide(player,boss))player.takeDamage(10);
        projectiles.forEach(p=>p.update()); projectiles=projectiles.filter(p=>p.active); projectiles.forEach(p=>p.draw(ctx));
        slashes.forEach(s=>s.update()); slashes=slashes.filter(s=>s.life>0); slashes.forEach(s=>s.draw(ctx));

        // 3. 繪製前景層 (前)
        bg.drawFront(ctx);
        ctx.restore();
    }
    ctx.fillStyle='white'; ctx.font='30px Courier New'; ctx.fillText("按 SPACE 進入深淵", 380, 300);
</script>
</body>
</html>