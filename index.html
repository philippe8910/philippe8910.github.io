<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <title>Hollow Slayer - Abyssal Ruins</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050508;
            /* æ›´æ·±é‚ƒçš„èƒŒæ™¯è‰² */
            font-family: 'Courier New', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            /* è®“ç•«å¸ƒé‚Šç·£ç™¼å…‰ï¼Œåƒæ˜¯åœ¨çœ‹ä¸€å€‹ç™¼å…‰çš„æ´ç©´ */
            box-shadow: 0 0 100px rgba(50, 50, 100, 0.3);
            background: linear-gradient(to bottom, #0d0d12 0%, #15151a 80%, #0a0a0d 100%);
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 800px;
            color: white;
            pointer-events: none;
            z-index: 10;
        }

        .bar-wrap {
            width: 100%;
            background: #222;
            height: 15px;
            border: 2px solid #444;
            margin-bottom: 5px;
            position: relative;
            box-shadow: 0 2px 5px black;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.1s;
        }

        #boss-hp-container {
            display: none;
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            z-index: 20;
        }

        #boss-hp {
            background: linear-gradient(to right, #900, #d00);
            width: 100%;
            box-shadow: 0 0 10px #d00;
        }

        #player-hp {
            background: linear-gradient(to right, #ccc, #fff);
            width: 100%;
            box-shadow: 0 0 10px #eee;
        }

        #heals {
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }

        .heal-orb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            background: transparent;
        }

        .heal-orb.filled {
            background: white;
            box-shadow: 0 0 15px white, inset 0 0 10px #aaf;
            border-color: white;
        }

        #msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 30px;
            color: white;
            text-shadow: 0 0 20px white;
            display: none;
            z-index: 20;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #777;
            font-size: 12px;
            z-index: 10;
            text-shadow: 1px 1px 2px black;
        }

        /* --- UI Windows --- */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            /* Fix overlap with mobile controls */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: auto;
        }

        .modal-content {
            background: #15151a;
            border: 2px solid #444;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .event-choices {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .choice-card {
            background: #222;
            border: 1px solid #555;
            padding: 20px;
            width: 200px;
            cursor: pointer;
            transition: 0.2s;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .choice-card:hover {
            background: #333;
            border-color: white;
            transform: scale(1.05);
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .inv-item {
            width: 60px;
            height: 60px;
            background: #222;
            border: 1px solid #444;
            position: relative;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
        }

        .inv-item:hover .tooltip {
            display: block;
        }

        .inv-item.equipped {
            border-color: gold;
            box-shadow: 0 0 5px gold;
        }

        .tooltip {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #111;
            border: 1px solid #666;
            padding: 5px;
            width: 150px;
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
        }

        .shop-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            background: #222;
            margin-bottom: 5px;
        }

        .btn {
            padding: 5px 15px;
            background: #444;
            color: white;
            border: 1px solid #666;
            border: 1px solid #666;
            cursor: pointer;
        }

        .btn:hover {
            background: #666;
        }

        /* Class Selection Styles */
        .class-card {
            background: #2a2a30;
            border: 2px solid #555;
            padding: 20px;
            width: 250px;
            cursor: pointer;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: 0.2s;
        }

        .class-card:hover {
            transform: scale(1.05);
            border-color: gold;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .class-icon {
            font-size: 50px;
            margin-bottom: 10px;
        }

        .class-desc {
            font-size: 14px;
            color: #aaa;
            min-height: 40px;
        }

        /* Toast Notification */
        #toast {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid gold;
            padding: 15px 30px;
            color: white;
            font-size: 20px;
            border-radius: 30px;
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s, top 0.3s;
        }

        #toast.show {
            opacity: 1;
            top: 15%;
        }

        /* --- æ‰‹æ©Ÿç‰ˆé©é… CSS --- */
        @media (max-width: 1024px) {
            #ui {
                width: 95%;
                top: 10px;
            }

            canvas {
                width: 100vw;
                height: 100vh;
                object-fit: contain;
            }

            .controls {
                display: none;
            }

            /* Mobile Fullscreen Modal */
            .modal-content {
                width: 98%;
                height: 90vh;
                /* Leave some space */
                max-width: none;
                padding: 10px;
                display: flex;
                flex-direction: column;
            }

            /* Scrollable Inventory Grid */
            .inv-grid {
                display: flex;
                flex-direction: column;
                gap: 10px;
                overflow-y: auto;
                max-height: 75vh;
                padding-bottom: 50px;
            }

            .inv-item {
                width: 100%;
                height: auto;
                min-height: 70px;
                font-size: 30px;
                justify-content: flex-start;
                padding: 0 20px;
                gap: 20px;
            }

            /* Mobile Info Layout */
            .item-info {
                display: flex !important;
                flex-direction: column;
                align-items: flex-start;
                text-align: left;
            }

            .item-info h4 {
                margin: 0;
                font-size: 18px;
                color: white;
            }

            .item-info p {
                margin: 5px 0 0;
                font-size: 14px;
                color: #aaa;
            }

            .tooltip {
                display: none !important;
            }
        }

        /* Desktop: Hide item info inside card */
        .item-info {
            display: none;
        }

        #rotate-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #050508;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
        }

        @media screen and (orientation: portrait) and (max-width: 1024px) {
            #rotate-warning {
                display: flex;
            }
        }

        #mobile-controls {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            user-select: none;
            -webkit-user-select: none;
        }

        @media (pointer: coarse) {
            #mobile-controls {
                display: block;
            }
        }

        .joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 160px;
            height: 160px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }

        #joystick-knob {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            left: 50px;
            top: 50px;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            pointer-events: none;
            transform: translate(0, 0);
            transition: 0.1s;
        }

        .action-zone {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            pointer-events: auto;
        }

        .m-btn {
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #555;
            border-radius: 50%;
            color: #ddd;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
            touch-action: manipulation;
        }

        .m-btn:active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.9);
            border-color: white;
        }

        #btn-atk {
            grid-column: 2;
            grid-row: 1;
            width: 90px;
            height: 90px;
            border-color: #ff5555;
            background: rgba(100, 0, 0, 0.2);
            font-size: 30px;
            margin-top: -20px;
        }

        #btn-jump {
            grid-column: 3;
            grid-row: 2;
            border-color: #5555ff;
        }

        #btn-dash {
            grid-column: 1;
            grid-row: 2;
            border-color: #55ff55;
        }

        #btn-heal {
            grid-column: 2;
            grid-row: 3;
            width: 60px;
            height: 60px;
            border-color: #ffff55;
            margin-top: 10px;
        }

        #btn-bag {
            grid-column: 3;
            grid-row: 1;
            width: 50px;
            height: 50px;
            border-color: gold;
            margin-top: -10px;
            margin-left: 20px;
        }
    </style>
</head>

<body>

    <div id="ui">
        <div style="display:flex; justify-content:space-between; align-items:flex-end;">
            <div>
                <span style="font-size: 20px; text-shadow: 0 0 5px white;">EXPLORER</span>
                <div id="heals">
                    <div class="heal-orb filled"></div>
                    <div class="heal-orb filled"></div>
                    <div class="heal-orb filled"></div>
                </div>
                <div style="font-size: 14px; margin-top: 5px; color: gold;">ğŸ’° <span id="gold-display">0</span></div>
            </div>
            <div style="text-align: right;">
                <span style="font-size: 24px; color: #ff4444; text-shadow: 0 0 15px red;">FLOOR <span
                        id="floor-num">1</span></span>
                <button onclick="toggleInventory()"
                    style="display:block; margin-top:5px; background:none; border:1px solid white; color:white; padding:5px;">ğŸ’
                    åŒ…åŒ…</button>
            </div>
        </div>
        <div class="bar-wrap" style="width: 30%; float:left; margin-top:5px;">
            <div id="player-hp" class="bar-fill"></div>
        </div>
        <div class="bar-wrap" style="width: 65%; float:right; margin-top:5px; opacity:0;">
            <div id="boss-hp" class="bar-fill"></div>
        </div>
    </div>

    <div id="msg">æŒ‰ä¸‹ SPACE æˆ– æ”»æ“Šéµ é€²å…¥åœ°ä¸‹åŸ<br><span style="font-size:16px; color:#aaa;">(é»æ“Šç•«é¢é–‹å§‹)</span></div>
    <div class="controls">ç§»å‹•: WASD | è·³èº: K | æ”»æ“Š: J | è¡åˆº: L | å›è¡€(æŒ‰ä½): Q | åŒ…åŒ…: I</div>

    <!-- Inventory Modal -->
    <!-- Inventory Modal -->
    <div id="ui-inventory" class="modal">
        <div class="modal-content" style="min-width: 600px;">
            <!-- Dynamic Content -->
            <div id="inv-content"></div>
        </div>
    </div>

    <!-- Event Modal -->
    <div id="ui-event" class="modal">
        <div class="modal-content" style="text-align:center;">
            <h2>å€åŸŸå®Œæˆ</h2>
            <p>é¸æ“‡ä½ çš„ä¸‹ä¸€æ­¥...</p>
            <div class="event-choices">
                <div class="choice-card" onclick="triggerEvent('left')">
                    <div style="font-size:40px;">â¬…ï¸</div>
                    <h3>å·¦é‚Šé€šé“</h3>
                    <p>æœªçŸ¥çš„å‘½é‹</p>
                </div>
                <div class="choice-card" onclick="triggerEvent('right')">
                    <div style="font-size:40px;">â¡ï¸</div>
                    <h3>å³é‚Šé€šé“</h3>
                    <p>æœªçŸ¥çš„å‘½é‹</p>
                </div>
                <div class="choice-card" id="btn-shop" onclick="openShop()">
                    <div style="font-size:40px;">ğŸª</div>
                    <h3>ç¥ç§˜å•†åº—</h3>
                    <p>äº¤æ˜“èˆ‡åˆæˆ</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Class Selection Modal -->
    <div id="ui-class" class="modal" style="display:flex;">
        <div class="modal-content" style="max-width: 900px;">
            <h2 style="text-align:center; margin-bottom:30px;">é¸æ“‡ä½ çš„å‘½é‹</h2>
            <div class="event-choices">
                <div class="class-card" onclick="chooseClass('thief')">
                    <div class="class-icon">ğŸ—¡ï¸</div>
                    <h3>ç›œè³Š (Thief)</h3>
                    <div class="class-desc">é«˜æš´æ“Šï¼Œæ•æ·ã€‚èµ·å§‹è£å‚™ï¼šåŒ•é¦– + çš®ç”²ã€‚<br>è¢«å‹•ï¼šæ‰è½ç‡å¢åŠ ã€‚</div>
                </div>
                <div class="class-card" onclick="chooseClass('archer')">
                    <div class="class-icon">ğŸ¹</div>
                    <h3>å¼“ç®­æ‰‹ (Archer)</h3>
                    <div class="class-desc">é ç¨‹æ”»æ“Šã€‚èµ·å§‹è£å‚™ï¼šå¼“ç®­ + çš®ç”²ã€‚<br>æ“…é•·ä¿æŒè·é›¢ã€‚</div>
                </div>
                <div class="class-card" onclick="chooseClass('swordsman')">
                    <div class="class-icon">âš”ï¸</div>
                    <h3>åŠå£« (Swordsman)</h3>
                    <div class="class-desc">é«˜å‚·å®³ï¼Œé«˜è¡€é‡ã€‚èµ·å§‹è£å‚™ï¼šå¤§åŠ + éµç”²ã€‚<br>è¿‘æˆ°å°ˆå®¶ã€‚</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Shop Modal -->
    <div id="ui-shop" class="modal">
        <div class="modal-content">
            <h2>ğŸª ç¥ç§˜å•†åº—</h2>
            <p>æŒæœ‰é‡‘å¹£: <span id="shop-gold" style="color:gold;">0</span></p>

            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <div style="flex:1; min-width:300px;">
                    <h3>è³¼è²·è£å‚™/è£œçµ¦</h3>
                    <div id="shop-buy-list"></div>
                </div>
                <div style="flex:1; min-width:300px;">
                    <h3>åˆæˆ / è²©è³£ç´ æ</h3>
                    <div id="shop-craft-list"></div>
                    <div style="margin-top:20px;">
                        <button class="btn" onclick="sellMaterials()">ä¸€éµè³£å‡ºæ‰€æœ‰ç´ æ</button>
                    </div>
                </div>
            </div>
            <button class="btn" style="margin-top:20px; width:100%; height:50px; font-size:20px;"
                onclick="nextLevel()">å‡ºç™¼å‰å¾€ä¸‹ä¸€å±¤</button>
        </div>
    </div>

    <!-- Loot Toast -->
    <div id="toast">ç²å¾— éª¨é ­ x1</div>

    <!-- Boss HP Bar -->
    <div id="boss-hp-container">
        <div style="text-align:center; text-shadow:2px 2px 2px black; font-weight:bold; font-size:24px;">âš ï¸ BOSS âš ï¸
        </div>
        <div class="bar-wrap">
            <div class="bar-fill" id="boss-hp" style="width: 100%;"></div>
        </div>
    </div>

    <!-- æ‰‹æ©Ÿç‰ˆè­¦å‘Š -->
    <div id="rotate-warning">
        <div style="font-size: 40px; margin-bottom: 20px;">ğŸ“±</div>
        <h2>è«‹è½‰å‹•æ‚¨çš„è£ç½®</h2>
        <p>ç‚ºäº†æœ€ä½³é«”é©—ï¼Œè«‹ä½¿ç”¨æ©«å‘æ¨¡å¼éŠç©</p>
    </div>

    <!-- æ‰‹æ©Ÿç‰ˆæ§åˆ¶å™¨ -->
    <div id="mobile-controls">
        <div class="joystick-zone" id="joystick">
            <div id="joystick-knob"></div>
        </div>
        <div class="action-zone">
            <div class="m-btn" id="btn-dash">â†</div>
            <div class="m-btn" id="btn-atk">âš”</div>
            <div class="m-btn" id="btn-jump">â‡ª</div>
            <div class="m-btn" id="btn-heal">+</div>
            <div class="m-btn" id="btn-bag" style="font-size:24px;">ğŸ’</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1000;
        canvas.height = 600;

        // --- ç‰©å“èˆ‡è³‡æ–™åº« ---
        const ITEMS = {
            // Daggers
            dagger: { id: 'dagger', name: 'åŒ•é¦–', type: 'weapon', atk: 5, spd: 1.5, icon: 'ğŸ—¡ï¸', desc: 'æ”»é€Ÿå¿«ï¼Œå‚·å®³ä½', price: 30 },
            dagger_curved: { id: 'dagger_curved', name: 'å½æ›²åŒ•é¦–', type: 'weapon', atk: 7, spd: 1.6, icon: 'ğŸ—¡ï¸', desc: 'ç¨ç‰¹é€ å‹ï¼Œæš´æ“Šé«˜', price: 60 },
            dagger_fast: { id: 'dagger_fast', name: 'å¿«é€ŸåŒ•é¦–', type: 'weapon', atk: 6, spd: 2.2, icon: 'âš¡', desc: 'æ¥µè‡´æ”»é€Ÿ', price: 90 },
            dagger_dual: { id: 'dagger_dual', name: 'é›™åˆƒåŒ•é¦–', type: 'weapon', atk: 9, spd: 1.8, icon: 'âš”ï¸', desc: 'é›™å€é‹’åˆ©', price: 120 },

            // Swords
            sword: { id: 'sword', name: 'å¤§åŠ', type: 'weapon', atk: 15, spd: 0.7, icon: 'âš”ï¸', desc: 'æ”»é€Ÿæ…¢ï¼Œå‚·å®³é«˜', price: 80 },
            sword_ultra: { id: 'sword_ultra', name: 'ç‰¹å¤§åŠ', type: 'weapon', atk: 25, spd: 0.5, icon: 'ğŸ—¡ï¸', desc: 'æ¥µåº¦æ²‰é‡ï¼Œç ´å£åŠ›å¼·', price: 180 },
            sword_iron: { id: 'sword_iron', name: 'éµå¤§åŠ', type: 'weapon', atk: 20, spd: 0.6, icon: 'ğŸ”©', desc: 'åšå¯¦çš„éµå¡Š', price: 140 },

            // Bows
            bow: { id: 'bow', name: 'å¼“ç®­', type: 'weapon', atk: 8, spd: 1.0, icon: 'ğŸ¹', desc: 'é ç¨‹æ”»æ“Š', price: 50 },
            bow_wood: { id: 'bow_wood', name: 'æœ¨å¼“', type: 'weapon', atk: 10, spd: 1.1, icon: 'ğŸªµ', desc: 'ç²¾è‰¯æœ¨æè£½ä½œ', price: 70 },
            bow_recurve: { id: 'bow_recurve', name: 'åæ›²å¼“', type: 'weapon', atk: 14, spd: 1.2, icon: 'ğŸ¹', desc: 'å¼·åŠ›å°„æ“Š', price: 110 },
            bow_silver: { id: 'bow_silver', name: 'éŠ€å¼“', type: 'weapon', atk: 18, spd: 1.3, icon: 'âœ¨', desc: 'ç¥è–éŠ€å…‰', price: 200 },

            bone_knife: { id: 'bone_knife', name: 'éª¨åˆ€', type: 'weapon', atk: 12, spd: 1.3, icon: 'ğŸ¦´', desc: 'éª¨é ­ç£¨è£½çš„åˆ€', price: 60 },

            // Armor
            leather: { id: 'leather', name: 'çš®ç”²', type: 'armor', def: 2, icon: 'ğŸ§¥', desc: 'è¼•ä¾¿çš„é˜²è­·', price: 40 },
            iron: { id: 'iron', name: 'éµç”²', type: 'armor', def: 5, icon: 'ğŸ›¡ï¸', desc: 'å …å›ºçš„é˜²ç¦¦', price: 100 },
            plate: { id: 'plate', name: 'æ¿ç”²', type: 'armor', def: 8, icon: 'ğŸ¯', desc: 'é‡å‹è£ç”²', price: 150 },
            beast_armor: { id: 'beast_armor', name: 'ç¸çš®é§ç”²', type: 'armor', def: 6, icon: 'ğŸ—', desc: 'é‡ç¸çš®æ¯›è£½æˆ', price: 120 },

            // Consumables (Potions)
            potion_s: { id: 'potion_s', name: 'å°ç“¶è—¥æ°´', type: 'use', effect: 'heal', val: 20, icon: 'ğŸ§ª', price: 20 },
            potion_m: { id: 'potion_m', name: 'ä¸­ç“¶è—¥æ°´', type: 'use', effect: 'heal', val: 50, icon: 'âš—ï¸', price: 50 },
            potion_l: { id: 'potion_l', name: 'å¤§ç“¶è—¥æ°´', type: 'use', effect: 'heal', val: 100, icon: 'ğŸ·', price: 100 },
            potion_mystery: { id: 'potion_mystery', name: 'ç¥ç§˜è—¥æ°´', type: 'use', effect: 'mystery', icon: 'ğŸ²', desc: 'éš¨æ©Ÿå›å¾© -50~50', price: 40 },
            potion_vio: { id: 'potion_vio', name: 'æš´åŠ›è—¥æ°´', type: 'use', effect: 'buff_atk', val: 5, icon: 'ğŸ’¥', desc: 'æœ¬å±¤æ”»æ“Š+5', price: 70 },
            potion_def: { id: 'potion_def', name: 'é˜²ç¦¦è—¥æ°´', type: 'use', effect: 'buff_def', val: 2, icon: 'ğŸ¢', desc: 'æœ¬å±¤é˜²ç¦¦+2', price: 60 },
            potion_crit: { id: 'potion_crit', name: 'çˆ†æ“Šè—¥æ°´', type: 'use', effect: 'buff_crit', val: 10, icon: 'ğŸ¯', desc: 'æœ¬å±¤çˆ†æ“Š+10%', price: 80 },
            slime_potion: { id: 'slime_potion', name: 'é»æ¶²è—¥æ°´', type: 'use', effect: 'slime_buff', icon: 'ğŸŸ¢', desc: 'å›è¡€+å°‘é‡é˜²ç¦¦', price: 50 },
            goblin_sack: { id: 'goblin_sack', name: 'ç¥ç§˜è¢‹å­', type: 'use', effect: 'box', icon: 'ğŸ’°', desc: 'ç²å¾—éš¨æ©Ÿé“å…·', price: 100 },


            // Special
            curse_blood: { id: 'curse_blood', name: 'æ¸´è¡€è©›å’’', icon: 'ğŸ©¸', desc: 'ç„¡æ³•å–æ°´ã€‚æ”»æ“Šå›è¡€ï¼Œæ®ç©ºæ‰£è¡€ã€‚' },
            curse_hunger: { id: 'curse_hunger', name: 'æ°¸æ†é£¢æ¸´', icon: 'ğŸ§Ÿ', desc: 'MaxHP=10ã€‚æ™®é€šå—å‚·1ï¼ŒBosså—å‚·5ã€‚' },
            curse_gambler: { id: 'curse_gambler', name: 'åæ®ºåšå¾’', icon: 'ğŸ²', desc: 'æœªçˆ†æ“Š0å‚·å®³ã€‚çˆ†æ“Šç‡+30%ã€‚' },

            bless_dawn: { id: 'bless_dawn', name: 'ç ´æ›‰ç¥ç¦', icon: 'ğŸŒ…', desc: 'æ¯å±¤é–‹å§‹å› 10 HPã€‚' },
            bless_str: { id: 'bless_str', name: 'åŠ›é‡ç¥ç¦', icon: 'ğŸ’ª', desc: 'å—å‚·åŠ æ”»æ“Š (æœ¬å±¤æœ‰æ•ˆ)ã€‚' },
            bless_fort: { id: 'bless_fort', name: 'å …æ¯…ç¥ç¦', icon: 'ğŸ›¡ï¸', desc: 'å—å‚·åŠ é˜²ç¦¦ (çŸ­æš«)ã€‚' },
            bless_will: { id: 'bless_will', name: 'æœ€çµ‚æ„å¿—', icon: 'â¤ï¸', desc: 'æŠµæ“‹ä¸€æ¬¡æ­»äº¡ä¸¦å›æ»¿è¡€ (æ¶ˆè€—)ã€‚' },
            bless_thief: { id: 'bless_thief', name: 'ç›œè³Šç¥ç¦', icon: 'ğŸ’°', desc: 'æ‰è½ç‡ 1.5 å€ã€‚' },
            bless_crit: { id: 'bless_crit', name: 'çˆ†æ“Šç¥ç¦', icon: 'ğŸ¯', desc: 'çˆ†æ“Šå‚·å®³ 200% -> 250%ã€‚' },
            bless_luck: { id: 'bless_luck', name: 'è³­å¾’ç¥ç¦', icon: 'ğŸ€', desc: 'çˆ†æ“Šç‡ +10%ã€‚' },

            // Special Chest Weapons
            axe_battle: { id: 'axe_battle', name: 'æˆ°æ–§', type: 'weapon', atk: 40, spd: 0.4, icon: 'ğŸª“', desc: 'å‚·å®³æ¥µé«˜ï¼Œç„¡æ³•è¡åˆºï¼Œç§»å‹•æ…¢', price: 999 },
            katana: { id: 'katana', name: 'æ­¦å£«åˆ€', type: 'weapon', atk: 18, spd: 1.2, icon: 'ğŸ—¡ï¸', desc: 'æ”»æ“Šè‡ªå¸¶è¡åˆºèˆ‡ç„¡æ•µ', price: 999 },
            glove_arcane: { id: 'glove_arcane', name: 'ç§˜è¡“æ‰‹å¥—', type: 'weapon', atk: 12, spd: 1.5, icon: 'ğŸ”®', desc: 'ç™¼å°„é­”æ³•å½ˆï¼Œç„¡ä¸‹å¢œ', price: 999 },
            sword_nameless: { id: 'sword_nameless', name: 'ç„¡åä¹‹åŠ', type: 'weapon', atk: 25, spd: 1.0, icon: 'âš”ï¸', desc: 'æ®èˆé‡‹æ”¾åŠæ°£', price: 999 },

            // Special Chest Weapons
            axe_battle: { id: 'axe_battle', name: 'æˆ°æ–§', type: 'weapon', atk: 40, spd: 0.4, icon: 'ğŸª“', desc: 'å‚·å®³æ¥µé«˜ï¼Œç„¡æ³•è¡åˆºï¼Œç§»å‹•æ…¢', price: 999 },
            katana: { id: 'katana', name: 'æ­¦å£«åˆ€', type: 'weapon', atk: 18, spd: 1.2, icon: 'ğŸ—¡ï¸', desc: 'æ”»æ“Šè‡ªå¸¶è¡åˆºèˆ‡ç„¡æ•µ', price: 999 },
            glove_arcane: { id: 'glove_arcane', name: 'ç§˜è¡“æ‰‹å¥—', type: 'weapon', atk: 12, spd: 1.5, icon: 'ğŸ”®', desc: 'ç™¼å°„é­”æ³•å½ˆï¼Œç„¡ä¸‹å¢œ', price: 999 },
            sword_nameless: { id: 'sword_nameless', name: 'ç„¡åä¹‹åŠ', type: 'weapon', atk: 25, spd: 1.0, icon: 'âš”ï¸', desc: 'æ®èˆé‡‹æ”¾åŠæ°£', price: 999 },

            // New Craftable Items
            sword_poison: { id: 'sword_poison', name: 'æ¯’æ¶²éµåŠ', type: 'weapon', atk: 18, spd: 1.0, icon: 'ğŸ¦ ', desc: 'æ”»æ“Šé™„åŠ åŠ‡æ¯’ç´¯ç©', price: 500 },
            armor_iron_wing: { id: 'armor_iron_wing', name: 'éµç¿¼é§ç”²', type: 'armor', def: 10, icon: 'ğŸ¦‡', desc: 'è³¦äºˆä¸‰æ®µè·³èƒ½åŠ›', price: 600 },

            // Materials
            goo: { id: 'goo', name: 'å²èŠå§†é»æ¶²', type: 'mat', icon: 'ğŸ’§', price: 5 },
            bone: { id: 'bone', name: 'éª¨é ­', type: 'mat', icon: 'ğŸ¦´', price: 8 },
            skin: { id: 'skin', name: 'ç¸çš®', type: 'mat', icon: 'ğŸ“œ', price: 15 },

            // New Materials
            iron_ore: { id: 'iron_ore', name: 'éµç¤¦', type: 'mat', icon: 'â›ï¸', price: 20 },
            acid_goo: { id: 'acid_goo', name: 'é…¸æ€§é»æ¶²', type: 'mat', icon: 'ğŸ§ª', price: 15 },
            bat_wing: { id: 'bat_wing', name: 'è™è ç¿…è†€', type: 'mat', icon: 'ğŸ¦‡', price: 12 },
        };

        const TRAITS = {
            curses: ['curse_blood', 'curse_hunger', 'curse_gambler'],
            blessings: ['bless_dawn', 'bless_str', 'bless_fort', 'bless_will', 'bless_thief', 'bless_crit', 'bless_luck',
                'bless_poison', 'bless_dragon', 'bless_thorns']
        };

        // Add new Blessings details to ITEMS (for lookup)
        ITEMS.bless_poison = { id: 'bless_poison', name: 'æ¯’ç‰™ç¥ç¦', icon: 'ğŸ', desc: 'æ”»æ“Šé€ æˆä¸­æ¯’ (3ç§’)' };
        ITEMS.bless_dragon = { id: 'bless_dragon', name: 'é¾æ¯ç¥ç¦', icon: 'ğŸ²', desc: 'è—¥æ°´å›å¾©æ•ˆæœå¢å¼·' };
        ITEMS.bless_thorns = { id: 'bless_thorns', name: 'èŠæ£˜é§ç”²', icon: 'ğŸŒ¹', desc: 'å—å‚·åå½ˆ 3 é»å‚·å®³' };

        const LOOT_TABLE = [
            'potion_s', 'potion_mystery', 'goo', 'bone', 'skin', 'dagger', 'leather', 'goblin_sack'
        ];

        // --- éŠæˆ²å…¨åŸŸè®Šæ•¸ ---
        const WORLD_WIDTH = 3000;
        const GROUND_Y = 550;

        let camera = { x: 0, y: 0 };
        let floor = 1;
        let particles = [], projectiles = [], slashes = [], drops = [];
        let platforms = [], enemies = [], spikes = [], texts = [];
        let screenShake = 0, hitStop = 0;
        let frame = 0, gameRunning = false, gameOver = false;
        let paused = false; // For UI Menu

        const keys = { left: false, right: false, up: false, atk: false, dash: false, heal: false };

        // UI Handling
        let invTab = 'bag'; // 'bag' or 'stats'

        function toggleInventory() {
            const ui = document.getElementById('ui-inventory');
            if (ui.style.display === 'flex') { ui.style.display = 'none'; paused = false; }
            else { ui.style.display = 'flex'; paused = true; renderInventory(); }
        }

        function switchTab(tab) {
            invTab = tab;
            renderInventory();
        }

        function renderInventory() {
            const content = document.querySelector('#ui-inventory .modal-content');

            // Tabs
            let html = `
                <div style="display:flex; justify-content:center; gap:10px; margin-bottom:20px;">
                    <button class="btn" style="${invTab === 'bag' ? 'border-color:gold' : ''}" onclick="switchTab('bag')">ğŸ’ è£å‚™è—¥æ°´</button>
                    <button class="btn" style="${invTab === 'mat' ? 'border-color:gold' : ''}" onclick="switchTab('mat')">ğŸªµ é›œç‰©ç´ æ</button>
                    <button class="btn" style="${invTab === 'stats' ? 'border-color:gold' : ''}" onclick="switchTab('stats')">ğŸ“Š ç‹€æ…‹ & ç¥ç¦</button>
                </div>
            `;

            if (invTab === 'bag') {
                html += `
                    <div style="display:flex; gap:20px; flex-wrap:wrap;">
                        <div style="flex:1; min-width:200px;">
                            <h3>è£å‚™ä¸­</h3>
                            <div id="equip-display" class="inv-grid" style="grid-template-columns: repeat(2, 1fr); height:auto;"></div>
                        </div>
                        <div style="flex:2; min-width:200px;">
                            <h3>èƒŒåŒ… (é»æ“Šä½¿ç”¨/è£å‚™)</h3>
                            <div id="inv-grid" class="inv-grid"></div>
                        </div>
                    </div>
                `;
                content.innerHTML = html;

                const equipDiv = document.getElementById('equip-display');
                if (player.equip.weapon) renderItem(equipDiv, player.equip.weapon, true);
                else equipDiv.innerHTML += '<div class="inv-item">ç„¡æ­¦å™¨</div>';
                if (player.equip.body) renderItem(equipDiv, player.equip.body, true);
                else equipDiv.innerHTML += '<div class="inv-item">ç„¡é˜²å…·</div>';

                const grid = document.getElementById('inv-grid');
                player.inventory.forEach((item, idx) => {
                    if (item.type === 'mat') return; // Hide mats in Bag

                    const div = document.createElement('div');
                    div.className = 'inv-item';
                    renderItemContent(div, item);
                    div.onclick = () => {
                        if (item.type === 'use') { player.useItem(item, idx); }
                        else if (item.type === 'weapon' || item.type === 'armor') { player.equipItem(item, idx); }
                    };
                    grid.appendChild(div);
                });
            } else if (invTab === 'mat') {
                html += `<h3>é›œç‰©èˆ‡ç´ æ</h3><div id="mat-grid" class="inv-grid"></div>`;
                content.innerHTML = html;
                const grid = document.getElementById('mat-grid');
                player.inventory.forEach((item, idx) => {
                    if (item.type !== 'mat') return; // Show only mats

                    const div = document.createElement('div');
                    div.className = 'inv-item';
                    renderItemContent(div, item);
                    grid.appendChild(div);
                });
                if (grid.innerHTML === '') grid.innerHTML = '<p style="color:#777; width:100%;">é€™è£¡ç©ºç©ºå¦‚ä¹Ÿ...</p>';

            } else {
                // Stats Tab
                html += `
                    <div style="text-align:left; padding:0 20px;">
                        <h3>åŸºç¤å±¬æ€§</h3>
                        <p>â­ ç­‰ç´š: ${player.level} (XP: ${player.xp} / ${player.maxXp})</p>
                        <p>â¤ï¸ ç”Ÿå‘½: ${Math.floor(player.hp)} / ${player.maxHp}</p>
                        <p>âš”ï¸ æ”»æ“Š: ${player.getAtk()} (åŸºç¤:${player.baseAtk} + è£å‚™:${player.equip.weapon?.atk || 0} + Buff:${player.buffs.atk})</p>
                        <p>ğŸ›¡ï¸ é˜²ç¦¦: ${player.getDef()} (åŸºç¤:${player.baseDef} + è£å‚™:${player.equip.body?.def || 0} + Buff:${player.buffs.def})</p>
                        <p>ğŸ¯ çˆ†æ“Šç‡: ${player.crit + player.buffs.crit}%</p>
                        <p>ğŸ’° é‡‘å¹£: ${player.gold}</p>
                        <hr style="border-color:#555; margin:15px 0;">
                        <h3>ç²å¾—çš„ç¥ç¦èˆ‡è©›å’’</h3>
                        <div id="trait-list" style="display:flex; flex-direction:column; gap:10px;"></div>
                    </div>
                `;
                content.innerHTML = html;

                const traitDiv = document.getElementById('trait-list');
                if (player.traits.length === 0) {
                    traitDiv.innerHTML = '<p style="color:#777;">æš«ç„¡ç‰¹æ®Šèƒ½åŠ›</p>';
                } else {
                    player.traits.forEach(t => {
                        const d = document.createElement('div');
                        d.className = 'inv-item'; // reuse style
                        d.style.width = 'auto';
                        d.style.padding = '10px 15px';
                        d.style.display = 'block';
                        d.style.textAlign = 'left';
                        d.style.height = 'auto';

                        d.innerHTML = `
                            <div style="font-size:18px; font-weight:bold;">${t.icon} ${t.name}</div>
                            <div style="font-size:14px; color:#aaa; margin-top:5px;">${t.desc}</div>
                        `;
                        traitDiv.appendChild(d);
                    });
                }
            }

            // Close Button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'btn';
            closeBtn.style.marginTop = '20px';
            closeBtn.style.width = '100%';
            closeBtn.innerText = 'é—œé–‰';
            closeBtn.onclick = toggleInventory;
            content.appendChild(closeBtn);
        }

        function renderItem(container, item, isEquip) {
            const div = document.createElement('div');
            div.className = 'inv-item equipped';
            renderItemContent(div, item);
            container.appendChild(div);
        }

        function renderItemContent(div, item) {
            div.innerHTML = item.icon;

            // Mobile Info
            let info = `<div class="item-info">
                 <h4>${item.name}</h4>
                 <p>${item.desc || ''}</p>
             </div>`;
            div.innerHTML += info;

            // Desktop Tooltip
            let extra = '';
            if (item.atk) extra = `<br><span style="color:#f88">âš”ï¸ ${item.atk}</span>`;
            if (item.def) extra = `<br><span style="color:#88f">ğŸ›¡ï¸ ${item.def}</span>`;
            if (item.effect) extra = `<br><span style="color:#8f8">âœ¨ ${item.val || ''}</span>`;

            div.innerHTML += `<div class="tooltip"><b>${item.name}</b><br>${item.desc || ''}${extra}</div>`;
        }

        // Shop & Events logic will be added below...


        // --- éµç›¤è¼¸å…¥ ---
        document.addEventListener('keydown', e => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
            if (e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'KeyK') { if (!keys.up) player.jump(); keys.up = true; }
            if (e.code === 'KeyJ') {
                if (!gameRunning && !paused) {
                    if (gameOver) resetGame(); else startGame();
                } else {
                    if (!keys.atk && !paused) player.attack();
                }
                keys.atk = true;
            }
            if (e.code === 'KeyL' || e.code === 'ShiftLeft') { if (!keys.dash) player.dashMove(); keys.dash = true; }
            if (e.code === 'KeyQ') keys.heal = true;
            if (e.code === 'KeyI') toggleInventory();
            if (e.code === 'Space' && gameOver) resetGame();
        });

        document.addEventListener('keyup', e => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
            if (e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'KeyK') keys.up = false;
            if (e.code === 'KeyJ') keys.atk = false;
            if (e.code === 'KeyL' || e.code === 'ShiftLeft') keys.dash = false;
            if (e.code === 'KeyQ') keys.heal = false;
        });

        // Toast Logic
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2000);
        }

        // Class Logic
        let selectedClass = 'thief';

        function chooseClass(type) {
            selectedClass = type;
            startGame();
        }

        function startGame() {
            // Init Player based on Class
            player = new Player(selectedClass);
            document.getElementById('ui-class').style.display = 'none';

            gameRunning = true;
            document.getElementById('msg').style.display = 'none';
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(err => { });
            }
            nextLevel(); // Gen Floor 1
            loop();
        }

        // --- è™›æ“¬æ–æ¡¿é‚è¼¯ ---
        const joystick = document.getElementById('joystick');
        const knob = document.getElementById('joystick-knob');
        let touchId = null;
        let joyStartX = 0, joyStartY = 0;

        joystick.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            touchId = touch.identifier;
            joyStartX = touch.clientX;
            joyStartY = touch.clientY;
            knob.style.transition = '0s';
        }, { passive: false });

        joystick.addEventListener('touchmove', e => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === touchId) {
                    const touch = e.changedTouches[i];
                    let dx = touch.clientX - joyStartX;
                    let dy = touch.clientY - joyStartY;
                    const dist = Math.min(Math.sqrt(dx * dx + dy * dy), 60); // é™åˆ¶ç§»å‹•åŠå¾‘
                    const angle = Math.atan2(dy, dx);

                    const moveX = Math.cos(angle) * dist;
                    const moveY = Math.sin(angle) * dist;

                    knob.style.transform = `translate(${moveX}px, ${moveY}px)`;

                    // åˆ¤æ–·æ–¹å‘
                    keys.left = dx < -20;
                    keys.right = dx > 20;

                    // å‘ä¸Šæ¨åˆ¤å®šç‚ºè·³èº (é¸æ“‡æ€§)
                    // if(dy < -40) { if(!keys.up) player.jump(); keys.up = true; } else { keys.up = false; }
                }
            }
        }, { passive: false });

        joystick.addEventListener('touchend', e => {
            e.preventDefault();
            touchId = null;
            knob.style.transition = '0.2s';
            knob.style.transform = `translate(0px, 0px)`;
            keys.left = false;
            keys.right = false;
            keys.up = false;
        });

        // --- è™›æ“¬æŒ‰éˆ•é‚è¼¯ ---
        const setupBtn = (id, keyName, autoRepeat = false, actionFunc = null) => {
            const btn = document.getElementById(id);

            const start = (e) => {
                e.preventDefault();
                // Action Logic
                if (actionFunc) actionFunc();

                // Set Key State
                keys[keyName] = true;
                btn.style.background = 'rgba(255,255,255,0.4)';
            };

            const end = (e) => {
                e.preventDefault();
                keys[keyName] = false;
                btn.style.background = '';
            };

            // Touch Events
            btn.addEventListener('touchstart', start, { passive: false });
            btn.addEventListener('touchend', end);
            btn.addEventListener('touchcancel', end); // Robustness

            // Mouse Events (for testing on PC without Touch emulation)
            btn.addEventListener('mousedown', start);
            btn.addEventListener('mouseup', end);
            btn.addEventListener('mouseleave', end);
        };

        setupBtn('btn-jump', 'up', false, () => player.jump());
        setupBtn('btn-atk', 'atk', false, () => {
            if (!gameRunning && !paused) {
                if (gameOver) resetGame(); else startGame();
            } else {
                if (!paused) player.attack();
            }
        });
        setupBtn('btn-dash', 'dash', false, () => player.dashMove());
        setupBtn('btn-heal', 'heal', true); // Heal åƒ…éœ€åµæ¸¬æŒ‰ä½
        setupBtn('btn-bag', 'bag', false, toggleInventory);



        // --- å…¨æ–°è¨­è¨ˆçš„å ´æ™¯é¡åˆ¥ (æ”¯æ´æ²å‹•) ---
        class Background {
            constructor() {
                // 1. é æ™¯ (è¦–å·®ä¿‚æ•¸ 0.2)
                this.distantRuins = [];
                for (let i = 0; i < 30; i++) { // å¢åŠ æ•¸é‡è¦†è“‹é•·åœ°åœ–
                    this.distantRuins.push({
                        x: i * 150 - 50,
                        w: 80 + Math.random() * 60,
                        h: 200 + Math.random() * 150,
                        offsetY: Math.random() * 20
                    });
                }

                // 2. ä¸­æ™¯ (è¦–å·®ä¿‚æ•¸ 0.5)
                this.pillars = [];
                for (let i = 0; i < 20; i++) {
                    this.pillars.push({ x: i * 280 + 50, w: 100 + Math.random() * 40, cracks: Math.random() > 0.5 });
                }

                // 3. å‰æ™¯ (è¦–å·®ä¿‚æ•¸ 1.2)
                this.foregroundObjects = [];
                for (let i = 0; i < 40; i++) {
                    this.foregroundObjects.push({
                        x: Math.random() * WORLD_WIDTH,
                        h: 50 + Math.random() * 150,
                        type: Math.random() > 0.7 ? 'chain' : 'vine'
                    });
                }

                // 4. ç²’å­ (è¦–çª—ç©ºé–“)
                this.dust = [];
                for (let i = 0; i < 30; i++) {
                    this.dust.push({
                        x: Math.random() * canvas.width, y: Math.random() * canvas.height,
                        size: Math.random() * 2.5, speed: Math.random() * 0.4 + 0.1, alpha: Math.random() * 0.5 + 0.2
                    });
                }
            }

            // ç¹ªè£½æœ€é çš„èƒŒæ™¯
            drawBack(ctx) {
                const slowMove = Math.sin(frame * 0.02) * 10;

                // è¦–å·®è¨ˆç®—: ç‰©ä»¶ä½ç½® - (ç›¸æ©Ÿä½ç½® * ä¿‚æ•¸)
                // 1. é æ™¯
                ctx.fillStyle = '#08080c';
                this.distantRuins.forEach(r => {
                    let rx = r.x - camera.x * 0.2;
                    if (rx > -200 && rx < canvas.width + 200) // åªç•«è¦–é‡å…§
                        ctx.fillRect(rx, 150 + r.offsetY + slowMove * 0.5, r.w, GROUND_Y);
                });

                // 2. ä¸­æ™¯
                this.pillars.forEach(p => {
                    let px = p.x - camera.x * 0.5;
                    if (px > -200 && px < canvas.width + 200) {
                        ctx.fillStyle = '#121218';
                        ctx.fillRect(px, 80 + slowMove, p.w, GROUND_Y - 80);
                        if (p.cracks) {
                            ctx.save();
                            ctx.shadowBlur = 15; ctx.shadowColor = '#4444ff';
                            ctx.strokeStyle = '#222255'; ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(px + 10, 100 + slowMove);
                            ctx.lineTo(px + p.w - 20, 250 + slowMove);
                            ctx.lineTo(px + 30, 400 + slowMove);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                });
            }

            // ç¹ªè£½å ´æ™¯ç‰©ä»¶ (å¹³å°ã€åœ°æ¿) -> é€™äº›è·Ÿéš¨ä¸–ç•Œåº§æ¨™ï¼Œä¸å¥—è¦–å·®ï¼Œä½†å— camera.x å½±éŸ¿ (åœ¨å¤–éƒ¨ transform ä¸‹ç¹ªè£½)
            drawWorld(ctx) {
                // åœ°æ¿
                ctx.fillStyle = '#0a0a0d';
                // ç”±æ–¼åœ°æ¿ç¾åœ¨æœ‰å‘æ´ï¼Œæˆ‘å€‘éœ€è¦ç¹ªè£½å…·é«”çš„å¹³å°
                platforms.forEach(p => {
                    ctx.fillStyle = p.type === 'wall' ? '#08080a' : '#0a0a0d';
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    // å¹³å°é‚Šç·£è£é£¾
                    ctx.fillStyle = '#1a1a22';
                    for (let i = p.x; i < p.x + p.w; i += 40) {
                        let h = Math.random() * 15;
                        ctx.beginPath(); ctx.moveTo(i, p.y); ctx.lineTo(i + 20, p.y - h); ctx.lineTo(i + 40, p.y); ctx.fill();
                    }
                    ctx.strokeStyle = '#222233'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(p.x, p.y + 1); ctx.lineTo(p.x + p.w, p.y + 1); ctx.stroke();
                });

                // å°–åˆº
                ctx.fillStyle = '#555';
                spikes.forEach(s => {
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y + s.h);
                    ctx.lineTo(s.x + s.w / 2, s.y);
                    ctx.lineTo(s.x + s.w, s.y + s.h);
                    ctx.fill();
                });

                // æ•™å­¸æ–‡å­—
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = '20px Courier New';
                ctx.textAlign = 'center';
                texts.forEach(t => {
                    ctx.fillText(t.str, t.x, t.y);
                });
                ctx.textAlign = 'left';
            }

            // ç¹ªè£½å‰æ™¯ (é®æ“‹ç‰©å’Œæ°›åœ) - è¦–å·®ä¿‚æ•¸ 1.2
            drawFront(ctx) {
                const fasterMove = Math.sin(frame * 0.03) * 15;
                ctx.fillStyle = '#040406';
                this.foregroundObjects.forEach(o => {
                    let ox = o.x - camera.x * 1.2;
                    if (ox > -50 && ox < canvas.width + 50) {
                        let sway = Math.sin(frame * 0.05 + o.x) * 5;
                        if (o.type === 'vine') {
                            ctx.beginPath();
                            ctx.moveTo(ox, 0);
                            ctx.quadraticCurveTo(ox + sway, o.h / 2, ox, o.h + fasterMove);
                            ctx.lineTo(ox + 10, o.h + fasterMove);
                            ctx.quadraticCurveTo(ox + sway + 10, o.h / 2, ox + 10, 0);
                            ctx.fill();
                        } else {
                            ctx.fillRect(ox + sway, -20, 5, o.h + fasterMove);
                        }
                    }
                });

                // 4. å¡µåŸƒç²’å­ (å¢åŠ ç’°å¢ƒå…‰æ„Ÿ)
                this.dust.forEach(d => {
                    d.y -= d.speed;
                    if (d.y < 0) d.y = canvas.height;
                    ctx.globalAlpha = d.alpha;
                    ctx.fillStyle = '#aaaaff'; // å¸¶é»è—è‰²çš„å¡µåŸƒ
                    ctx.beginPath(); ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2); ctx.fill();
                });
                ctx.globalAlpha = 1;

                // 5. å¼·çƒˆçš„æš—è§’æ•ˆæœ (Vignette) - èšç„¦ä¸­å¿ƒ
                const grad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 250, canvas.width / 2, canvas.height / 2, 700);
                grad.addColorStop(0, 'transparent');
                grad.addColorStop(0.7, 'rgba(0,0,0,0.5)');
                grad.addColorStop(1, 'rgba(0,0,0,0.9)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // --- (ä»¥ä¸‹ç‚ºæ—¢æœ‰çš„éŠæˆ²é‚è¼¯é¡åˆ¥ï¼Œæœªåšå¤§å¹…ä¿®æ”¹ï¼Œåƒ…é…åˆå ´æ™¯èª¿æ•´é¡è‰²) ---
        class SlashAnim {
            constructor(x, y, facing) {
                this.x = x; this.y = y; this.facing = facing; this.life = 1.0; this.angle = facing === 1 ? -0.5 : 3.5;
            }
            update() { this.life -= 0.15; this.x += this.facing * 2; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.scale(this.facing, 1);
                ctx.beginPath(); ctx.arc(0, 0, 60, -0.5, 0.5 + (1 - this.life));
                ctx.lineWidth = 20 * this.life; ctx.strokeStyle = `rgba(255, 255, 255, ${this.life})`;
                ctx.shadowBlur = 20; ctx.shadowColor = 'cyan'; // æ”¹ç‚ºå†·è‰²èª¿åˆ€å…‰
                ctx.stroke(); ctx.restore();
            }
        }
        class Particle {
            constructor(x, y, color, speed, size) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random() - 0.5) * speed; this.vy = (Math.random() - 0.5) * speed;
                this.life = 1.0; this.size = size;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.04; this.size *= 0.95; }
            draw(ctx) {
                ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
                ctx.shadowBlur = 5; ctx.shadowColor = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1; ctx.shadowBlur = 0;
            }
        }
        class Player {
            constructor(classType) {
                this.w = 30; this.h = 50; this.x = 100; this.y = GROUND_Y - 50; this.vx = 0; this.vy = 0; this.facing = 1;
                this.hp = 100; this.maxHp = 100; this.heals = 3; this.healTimer = 0; this.healTimeMax = 90;
                this.jumps = 0; this.dashing = false; this.dashTime = 0; this.dashCooldown = 0;
                this.atkCooldown = 0; this.invincible = 60; this.grounded = false;

                // RPG Stats
                this.gold = 0;
                this.baseAtk = 10;
                this.baseDef = 0;
                this.crit = 5;
                this.buffs = { atk: 0, def: 0, crit: 0 };
                this.traits = []; // Blessings and Curses
                this.tempAtk = 0; this.tempDef = 0; // For temporary buffs

                // Class Init
                if (classType === 'thief') {
                    this.equip = { weapon: ITEMS.dagger, body: ITEMS.leather };
                    this.traits.push(ITEMS.bless_thief);
                    this.crit = 15;
                } else if (classType === 'archer') {
                    this.equip = { weapon: ITEMS.bow, body: ITEMS.leather };
                } else { // swordsman
                    this.equip = { weapon: ITEMS.sword, body: ITEMS.iron };
                    this.maxHp = 120; this.hp = 120;
                }

                this.inventory = [ITEMS.potion_s];

                // Level System
                this.level = 1;
                this.xp = 0;
                this.maxXp = 100;

                this.updateHealUI();
            }

            gainXp(amount) {
                this.xp += Math.floor(amount);
                if (this.xp >= this.maxXp) {
                    this.xp -= this.maxXp;
                    this.level++;
                    this.maxXp = Math.floor(this.maxXp * 1.2);

                    // Stat Growth
                    this.baseAtk += 2;
                    this.baseDef += 1;
                    this.maxHp += 10;
                    this.hp = this.maxHp;

                    showToast(`å‡ç´šï¼ç­‰ç´š ${this.level} (æ”»+2 é˜²+1 è¡€+10)`);
                    spawnParticles(this.x, this.y, 'gold', 20, 5);
                }
            }

            getAtk() { return this.baseAtk + (this.equip.weapon?.atk || 0) + this.buffs.atk + this.tempAtk; }
            getDef() { return this.baseDef + (this.equip.body?.def || 0) + this.buffs.def + this.tempDef; }
            getSpd() { return this.equip.weapon?.spd || 1.0; }

            hasTrait(id) { return this.traits.some(t => t.id === id); }

            useItem(item, idx) {
                if (this.hasTrait('curse_blood') && item.effect === 'heal') {
                    showToast("æ¸´è¡€è©›å’’ï¼šç„¡æ³•å–æ°´ï¼"); return;
                }

                let consumed = true;
                if (item.effect === 'heal') {
                    let healVal = item.val;
                    if (this.hasTrait('bless_dragon')) healVal *= 1.5;
                    this.hp = Math.min(this.hp + healVal, this.maxHp);
                    spawnParticles(this.x, this.y, 'green', 10, 3);
                }
                else if (item.effect === 'mystery') { const val = Math.floor(Math.random() * 101) - 50; this.hp += val; spawnParticles(this.x, this.y, val > 0 ? 'green' : 'red', 10, 3); if (this.hp <= 0) endGame(false); }
                else if (item.effect === 'buff_atk') { this.buffs.atk += item.val; }
                else if (item.effect === 'buff_def') { this.buffs.def += item.val; }
                else if (item.effect === 'buff_crit') { this.buffs.crit += item.val; }
                else if (item.effect === 'slime_buff') { this.hp += 20; this.buffs.def += 1; }
                else if (item.effect === 'box') {
                    consumed = true;
                    const keys = Object.keys(ITEMS);
                    const r = ITEMS[keys[Math.floor(Math.random() * keys.length)]];
                    this.inventory.push(r);
                    showToast(`æ‰“é–‹è¢‹å­ç²å¾—: ${r.name}`);
                }
                if (consumed) this.inventory.splice(idx, 1);
                this.updateHealUI();

                // Optimized Refresh: Only if UI is open
                if (document.getElementById('ui-inventory').style.display === 'flex') {
                    renderInventory();
                }
            }

            equipItem(item, idx) {
                // Correct Swap Logic
                if (idx !== undefined && idx >= 0) {
                    this.inventory.splice(idx, 1);
                }

                let oldItem = null;
                if (item.type === 'weapon') {
                    oldItem = this.equip.weapon;
                    this.equip.weapon = item;
                }
                if (item.type === 'armor') {
                    oldItem = this.equip.body;
                    this.equip.body = item;
                }

                if (oldItem) this.inventory.push(oldItem);

                showToast(`è£å‚™äº† ${item.name}`);

                // Optimized Refresh
                if (document.getElementById('ui-inventory').style.display === 'flex') {
                    renderInventory();
                }
            }

            jump() {
                let maxJumps = 2;
                if (this.equip.body?.id === 'armor_iron_wing') maxJumps = 3; // Triple Jump

                if (this.jumps < maxJumps) { this.vy = -13; this.jumps++; spawnParticles(this.x + 15, this.y + 50, '#555', 5, 4); }
            }
            dashMove() {
                if (this.equip.weapon?.id === 'axe_battle') { showToast('å¤ªé‡äº†ï¼ç„¡æ³•è¡åˆº'); return; }
                if (this.dashCooldown <= 0 && !this.dashing) { this.dashing = true; this.dashTime = 12; this.dashCooldown = 50; this.vx = this.facing * 22; this.vy = 0; spawnParticles(this.x, this.y + 25, 'cyan', 10, 3); }
            }

            attack() {
                const spd = this.getSpd();
                if (this.atkCooldown <= 0) {
                    this.atkCooldown = 25 * spd;
                    let hitCount = 0;

                    // Katana Dash
                    if (this.equip.weapon?.id === 'katana') {
                        this.dashing = true; this.dashTime = 5; this.vx = this.facing * 20; this.vy = 0; this.invincible = 10;
                    }

                    // å¼“ç®­é‚è¼¯
                    if (this.equip.weapon?.id === 'bow' || this.equip.weapon?.type === 'weapon' && this.equip.weapon.id.startsWith('bow')) {
                        projectiles.push(new Projectile(this.x + 20 * this.facing, this.y + 25, 15 * this.facing, 0, 30, 5, 'white', true));
                        return; // Bow stops here
                    }
                    // Arcane Glove
                    if (this.equip.weapon?.id === 'glove_arcane') {
                        projectiles.push(new Projectile(this.x + 20 * this.facing, this.y + 25, 10 * this.facing, 0, 20, 20, 'purple', true));
                        // No gravity logic in Projectile need
                    }
                    // Nameless Sword
                    if (this.equip.weapon?.id === 'sword_nameless') {
                        projectiles.push(new Projectile(this.x + 20 * this.facing, this.y + 25, 12 * this.facing, 0, 10, 40, 'cyan', true));
                    }

                    // è¿‘æˆ°é‚è¼¯ (Melee) - Arcane Glove skips this? No, Glove is Ranged.
                    if (this.equip.weapon?.id !== 'glove_arcane') {
                        slashes.push(new SlashAnim(this.facing === 1 ? this.x + 40 : this.x - 40, this.y + 25, this.facing));
                        const hitBox = { x: this.facing === 1 ? this.x : this.x - 70, y: this.y - 10, w: 100, h: 70 };

                        enemies.forEach(e => {
                            if (e.hp > 0 && checkRectCollide(hitBox, e)) {
                                let critRate = this.crit + this.buffs.crit;
                                if (this.hasTrait('curse_gambler')) critRate += 30;
                                if (this.hasTrait('bless_luck')) critRate += 10;
                                // Dagger Curved (High Crit)
                                if (this.equip.weapon?.id === 'dagger_curved') critRate += 20;

                                let isCrit = Math.random() * 100 < critRate;

                                // Gambler Curse
                                if (this.hasTrait('curse_gambler') && !isCrit) {
                                    spawnParticles(e.x, e.y, 'gray', 2, 2); // whiff
                                } else {
                                    let critMult = this.hasTrait('bless_crit') ? 2.5 : 2.0;
                                    let dmg = this.getAtk() * (isCrit ? critMult : 1);

                                    // Poison Blessing or Poison Sword
                                    if (this.hasTrait('bless_poison') || this.equip.weapon?.id === 'sword_poison') {
                                        if (!e.poison) e.poison = 0;
                                        e.poison += 3; // 3 ticks
                                        showToast('æ–½åŠ ä¸­æ¯’!');
                                    }

                                    e.takeDamage(dmg);
                                    hitStop = 4; screenShake = isCrit ? 8 : 2;
                                    spawnParticles(e.x + e.w / 2, e.y + e.h / 2, isCrit ? 'gold' : 'wheat', 10, 3);
                                }
                                hitCount++;
                            }
                        });
                    }

                    // Blood Curse
                    if (this.hasTrait('curse_blood')) {
                        if (hitCount > 0) { this.hp = Math.min(this.hp + 5, this.maxHp); showToast("å—œè¡€: +5HP"); }
                        else { this.hp -= 5; showToast("å—œè¡€æ®ç©º: -5HP"); if (this.hp <= 0) endGame(false); }
                        this.updateHealUI();
                    }
                }
            }

            healLogic() {
                if (this.hasTrait('curse_blood')) return;
                if (keys.heal && Math.abs(this.vx) < 1 && this.grounded && this.heals > 0 && this.hp < this.maxHp) {
                    this.healTimer++; if (frame % 5 === 0) spawnParticles(this.x + Math.random() * 30, this.y + Math.random() * 50, 'white', 2, 2);
                    if (this.healTimer >= this.healTimeMax) { this.hp = Math.min(this.hp + 34, this.maxHp); this.heals--; this.healTimer = 0; this.updateHealUI(); spawnParticles(this.x + 15, this.y + 25, 'white', 30, 5); screenShake = 5; }
                } else { this.healTimer = 0; }
            }
            updateHealUI() {
                document.querySelectorAll('.heal-orb').forEach((orb, i) => orb.classList.toggle('filled', i < this.heals));
                document.getElementById('player-hp').style.width = (this.hp / this.maxHp * 100) + '%';
                document.getElementById('gold-display').innerText = this.gold;
                document.getElementById('player-hp').style.backgroundColor = this.hasTrait('curse_hunger') ? '#550055' : '#ff4444';
            }
            takeDamage(amt) {
                if (this.dashing || this.invincible > 0) return;

                let realDmg = 0;
                if (this.hasTrait('curse_hunger')) {
                    // Boss check? We don't have "source" here, assume boss damage is > 20
                    realDmg = (amt > 20) ? 5 : 1;
                } else {
                    realDmg = Math.max(1, amt - this.getDef());
                }

                if (this.hasTrait('bless_str')) { this.tempAtk += 2; showToast("åŠ›é‡ç¥ç¦: æ”»æ“Šæå‡"); }
                if (this.hasTrait('bless_fort')) { this.tempDef += 5; setTimeout(() => this.tempDef -= 5, 5000); showToast("å …æ¯…ç¥ç¦: é˜²ç¦¦æå‡"); }

                this.hp -= realDmg; this.invincible = 60; this.healTimer = 0; screenShake = 12; this.updateHealUI(); spawnParticles(this.x + 15, this.y + 25, 'red', 15, 6);

                if (this.hp <= 0) {
                    if (this.hasTrait('bless_will')) {
                        this.hp = this.maxHp;
                        this.traits = this.traits.filter(t => t.id !== 'bless_will');
                        showToast("æœ€çµ‚æ„å¿—è§¸ç™¼ï¼");
                        screenShake = 30;
                        spawnParticles(this.x, this.y, 'gold', 50, 10);
                        return;
                    }
                    endGame(false);
                }
            }
            update() {
                if (this.dashCooldown > 0) this.dashCooldown--; if (this.atkCooldown > 0) this.atkCooldown--; if (this.invincible > 0) this.invincible--; this.healLogic();

                if (this.dashing) {
                    this.dashTime--; this.x += this.vx;
                    if (this.dashTime <= 0) { this.dashing = false; this.vx = 0; }
                } else {
                    if (this.healTimer > 0) { this.vx = 0; }
                    else {
                        let spd = 6;
                        // Battle Axe Slow
                        if (this.equip.weapon?.id === 'axe_battle') spd = 3;

                        if (keys.left) { this.vx = -spd; this.facing = -1; }
                        else if (keys.right) { this.vx = spd; this.facing = 1; }
                        else { this.vx *= 0.8; }
                    }
                    this.vy += 0.6; this.x += this.vx; this.y += this.vy;
                }

                // ç‰©ç†èˆ‡ç¢°æ’
                if (this.x < 0) this.x = 0;
                if (this.x > WORLD_WIDTH - this.w) this.x = WORLD_WIDTH - this.w;

                this.grounded = false;
                platforms.forEach(p => {
                    if (this.vy >= 0 &&
                        this.x + this.w > p.x && this.x < p.x + p.w &&
                        this.y + this.h >= p.y && this.y + this.h <= p.y + 20) {
                        this.y = p.y - this.h;
                        this.vy = 0;
                        this.grounded = true;
                        this.jumps = 0;
                    }
                });

                if (this.y > canvas.height + 100) {
                    this.hp -= 20; this.updateHealUI();
                    this.x = 100; this.y = GROUND_Y - 100; this.vx = 0; this.vy = 0;
                    screenShake = 10;
                    if (this.hp <= 0) endGame(false);
                }

                spikes.forEach(s => {
                    if (checkRectCollide(this, s) && this.invincible <= 0) {
                        this.takeDamage(10);
                        this.vy = -10;
                        this.x -= this.facing * 50;
                    }
                });
            }
            draw(ctx) {
                if (this.invincible > 0 && frame % 4 === 0) return;
                ctx.fillStyle = 'white'; ctx.shadowBlur = 20; ctx.shadowColor = 'white'; ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.fillStyle = 'black'; ctx.shadowBlur = 0; ctx.fillRect(this.facing === 1 ? this.x + 18 : this.x + 4, this.y + 10, 8, 20);
                if (this.healTimer > 0) { ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x + 15, this.y - 20, 10, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * (this.healTimer / this.healTimeMax))); ctx.stroke(); }
            }
        }
        // --- æ€ªç‰©é¡åˆ¥ ---
        class Enemy {
            constructor(x, y, name, color, hp, speed, dropItem) {
                this.x = x; this.y = y; this.w = 40; this.h = 60; this.name = name; this.color = color;
                this.hp = hp; this.maxHp = hp; this.vx = 0; this.vy = 0; this.speed = speed; this.dropItem = dropItem;
                this.state = 'IDLE'; this.timer = 0; this.facing = -1;
            }
            takeDamage(amt) {
                this.hp -= amt;
                spawnParticles(this.x + 20, this.y + 20, this.color, 5, 2);
                // æ“Šé€€
                this.vx = (player.x < this.x ? 3 : -3);

                if (this.hp <= 0) {
                    this.die();
                }
            }
            die() {
                player.gold += Math.floor(Math.random() * 40) + 20; // Increased Gold Drop
                player.updateHealUI();
                if (Math.random() < 0.7 && this.dropItem) { // Increased Item Drop Rate to 70%
                    drops.push({ x: this.x, y: this.y, item: this.dropItem });
                    // Thief Blessing: Chance for extra drop
                    if (player.hasTrait('bless_thief') && Math.random() < 0.5) {
                        drops.push({ x: this.x + 10, y: this.y, item: this.dropItem });
                    }
                }
                // XP Reward
                player.gainXp(this.maxHp / 2 + 10);
            }
            update() {
                if (this.hp <= 0) return;
                this.timer--;

                // State Machine
                if (this.state === 'IDLE') {
                    if (this.timer <= 0) { this.state = 'MOVE'; this.timer = Math.random() * 60 + 30; this.vx = (Math.random() - 0.5) * this.speed; }
                }
                else if (this.state === 'MOVE') {
                    this.x += this.vx;
                    if (this.x < 0 || this.x > WORLD_WIDTH) this.vx *= -1;
                    if (this.timer <= 0) { this.state = 'IDLE'; this.timer = 60; this.vx = 0; }

                    // Chase Player
                    if (Math.abs(player.x - this.x) < 300) {
                        this.vx = (player.x < this.x ? -1 : 1) * this.speed;
                    }
                }

                // Poison Logic
                if (this.poison && this.poison > 0) {
                    if (frame % 60 === 0) {
                        this.takeDamage(1);
                        this.poison--;
                        spawnParticles(this.x + 20, this.y, 'green', 3, 2);
                    }
                }

                // Physics (Gravity & Ground)
                this.vy += 1;
                this.y += this.vy;
                if (this.y > GROUND_Y - this.h) {
                    this.y = GROUND_Y - this.h;
                    this.vy = 0;
                }

                // Collision with Player
                if (checkRectCollide(this, player)) {
                    if (player.hasTrait('bless_thorns')) {
                        this.takeDamage(3);
                        spawnParticles(this.x + 20, this.y + 20, 'green', 5, 2);
                    }
                    player.takeDamage(10);
                }
            }
            draw(ctx) {
                if (this.hp <= 0) return;
                ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.w, this.h);
                // HP Bar
                ctx.fillStyle = 'red'; ctx.fillRect(this.x, this.y - 10, this.w, 5);
                ctx.fillStyle = '#0f0'; ctx.fillRect(this.x, this.y - 10, this.w * (this.hp / this.maxHp), 5);
            }
        }

        class Slime extends Enemy {
            constructor(x, y) { super(x, y, 'Slime', '#00ff00', 30, 1, ITEMS.goo); }
            die() {
                // Acid Goo Drop Chance
                if (Math.random() < 0.3) drops.push({ x: this.x, y: this.y, item: ITEMS.acid_goo });
                super.die();
            }
            update() {
                // Jump Logic
                if (frame % 60 === 0 && this.vy === 0) this.vy = -12;
                super.update();
            }
        }
        class Goblin extends Enemy {
            constructor(x, y) { super(x, y, 'Goblin', '#55aa55', 50, 4, ITEMS.goblin_sack); } // Fast
            die() {
                // Iron Ore Drop Chance
                if (Math.random() < 0.3) drops.push({ x: this.x, y: this.y, item: ITEMS.iron_ore });
                super.die();
            }
        }
        class Orc extends Enemy {
            constructor(x, y) { super(x, y, 'Orc', '#885555', 120, 1.5, ITEMS.skin); this.w = 60; this.h = 80; }
        }
        class Skeleton extends Enemy {
            constructor(x, y) { super(x, y, 'Skeleton', '#eeeeee', 40, 1, ITEMS.bone); }
            update() {
                if (this.hp <= 0) return;
                this.timer--;
                // é€ƒé›¢ç©å®¶
                if (Math.abs(player.x - this.x) < 200) {
                    this.vx = (player.x < this.x ? 2 : -2);
                    this.x += this.vx;
                }
                // å°„ç®­
                if (frame % 120 === 0 && Math.abs(player.x - this.x) < 600) {
                    let dir = (player.x < this.x ? -1 : 1);
                    projectiles.push(new Projectile(this.x, this.y + 20, dir * 8, -2, 20, 5, 'white'));
                }
                this.y = GROUND_Y - this.h;

                if (checkRectCollide(this, player)) {
                    player.takeDamage(10);
                }
            }
        }



        class Bat extends Enemy {
            constructor(x, y) { super(x, y, 'Bat', '#5555aa', 20, 3, ITEMS.bat_wing); this.w = 30; this.h = 30; this.startY = y; }
            update() {
                if (this.hp <= 0) return;
                this.x += (Math.sin(frame * 0.05) * 2); // Float
                this.y = this.startY + Math.sin(frame * 0.1) * 50; // Fly up down

                if (Math.abs(player.x - this.x) < 300) {
                    this.x += (player.x < this.x ? -1 : 1) * 2;
                }
                if (checkRectCollide(this, player)) player.takeDamage(5); // Weak attack
            }
        }

        class Boss extends Enemy {
            constructor(x, y, name, color, hp, item) {
                super(x, y, name, color, hp, 1, item);
                this.w = 100; this.h = 120;
                this.actionTimer = 0;
                this.isBoss = true;
            }
            update() {
                if (this.hp <= 0) { document.getElementById('boss-hp-container').style.display = 'none'; return; }

                // Boss HP Bar Update
                const bar = document.getElementById('boss-hp');
                const container = document.getElementById('boss-hp-container');
                container.style.display = 'block';
                bar.style.width = (this.hp / this.maxHp * 100) + '%';

                this.actionLogic();


                // Physics
                this.vy += 1;
                this.y += this.vy;
                if (this.y > GROUND_Y - this.h) {
                    this.y = GROUND_Y - this.h;
                    this.vy = 0;
                }

                if (checkRectCollide(this, player)) player.takeDamage(15);
            }
            actionLogic() { } // Override
        }

        class Troll extends Boss {
            constructor(x, y) { super(x, y, 'Giant Troll', '#558855', 800, ITEMS.potion_l); }
            actionLogic() {
                this.actionTimer++;
                if (Math.abs(player.x - this.x) > 50) this.x += (player.x < this.x ? -0.5 : 0.5); // Slow chase

                if (this.actionTimer > 180) {
                    this.actionTimer = 0;
                    const r = Math.random();
                    if (r < 0.3) { showToast('å·¨é­”æ€’å¼!'); screenShake = 20; player.vx = (player.x < this.x ? -20 : 20); }
                    else if (r < 0.6) {
                        showToast('å·¨é­”æŠ•çŸ³!');
                        projectiles.push(new Projectile(this.x, this.y + 20, (player.x < this.x ? -10 : 10), -5, 40, 40, '#555'));
                    }
                    else { showToast('å·¨é­”é‡æ“Š!'); this.vx = (player.x < this.x ? -10 : 10); setTimeout(() => this.vx = 0, 500); }
                }
            }
        }

        class Dragon extends Boss {
            constructor(x, y) {
                super(x, y, 'Fire Dragon', '#aa0000', 3000, ITEMS.sword_nameless);
                this.w = 150; this.h = 100;
                this.state = 'FLY'; // FLY, LAND, ROAR
                this.timer = 0;
            }
            actionLogic() {
                this.timer++;

                if (this.state === 'FLY') {
                    this.y = GROUND_Y - 300 + Math.sin(frame * 0.05) * 50; // Hover high
                    if (this.timer % 60 === 0) {
                        // Shoot Fireball
                        projectiles.push(new Projectile(this.x, this.y + 50, (player.x < this.x ? -8 : 8), 5, 30, 30, 'orange'));
                    }
                    if (this.timer > 300) { this.state = 'LAND'; this.timer = 0; showToast('å·¨é¾é™è‡¨!'); }
                }
                else if (this.state === 'LAND') {
                    this.vy += 1; // Fall fast
                    if (this.y >= GROUND_Y - this.h) {
                        this.y = GROUND_Y - this.h;
                        if (this.vy > 5) { screenShake = 30; if (player.grounded) player.takeDamage(15); } // Landing Quake
                        this.vy = 0;
                        if (this.timer > 120) { this.state = 'ROAR'; this.timer = 0; }
                    }
                }
                else if (this.state === 'ROAR') {
                    if (this.timer === 1) {
                        showToast('å·¨é¾å’†å“®!!!');
                        screenShake = 40;
                        // Debuff
                        player.vx = (player.x < this.x ? -30 : 30); // Knockback
                        player.buffs.def -= 5; setTimeout(() => player.buffs.def += 5, 5000);
                    }
                    if (this.timer > 60) { this.state = 'FLY'; this.timer = 0; this.vy = -10; }
                }
            }
            update() {
                // Manual Boss Update to allow Flying
                if (this.hp <= 0) { document.getElementById('boss-hp-container').style.display = 'none'; return; }
                const bar = document.getElementById('boss-hp');
                document.getElementById('boss-hp-container').style.display = 'block';
                bar.style.width = (this.hp / this.maxHp * 100) + '%';

                this.actionLogic();

                // No forced ground snap if Flying
                if (this.state !== 'FLY') {
                    this.y += this.vy;
                    if (this.y > GROUND_Y - this.h) { this.y = GROUND_Y - this.h; this.vy = 0; }
                }

                if (checkRectCollide(this, player)) player.takeDamage(15);
            }
            die() {
                super.die();
                endGame(true); // True Ending
            }
        }

        class GiantSlime extends Boss {
            constructor(x, y) { super(x, y, 'King Slime', '#00ff00', 600, ITEMS.slime_potion); }
            actionLogic() {
                this.actionTimer++;
                if (this.actionTimer > 120) {
                    this.actionTimer = 0;
                    if (Math.random() < 0.5) {
                        showToast('å²èŠå§†å¬å–š!');
                        enemies.push(new Slime(this.x + (Math.random() - 0.5) * 100, GROUND_Y));
                    } else {
                        showToast('æ³°å±±å£“é ‚!');
                        this.vy = -15;
                    }
                }
            }
        }

        class Projectile {
            constructor(x, y, vx, vy, w, h, c = 'orange', isPlayer = false) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.w = w; this.h = h; this.color = c; this.active = true; this.isPlayer = isPlayer; }
            update() {
                this.x += this.vx; this.y += this.vy;
                if (this.y > canvas.height + 200) this.active = false;

                // Arcane Glove: No Gravity
                if (this.color === 'purple') this.vy = 0;
                else this.vy += 0.1; // é‡åŠ›

                if (this.active) {
                    if (this.isPlayer) {
                        enemies.forEach(e => {
                            if (e.hp > 0 && checkRectCollide(this, e)) { e.takeDamage(10 + player.getAtk()); this.active = false; }
                        });
                    } else {
                        if (checkRectCollide(this, player)) { player.takeDamage(10); this.active = false; }
                    }
                }
            }
            draw(ctx) { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.w, this.h); }
        }

        function checkRectCollide(r1, r2) { return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y); }
        function spawnParticles(x, y, c, cnt, sz) { for (let i = 0; i < cnt; i++)particles.push(new Particle(x, y, c, 8, sz)); }

        function resetGame() {
            // Show Class Selection instead of starting immediately
            document.getElementById('msg').style.display = 'none';
            document.getElementById('ui-class').style.display = 'flex';

            // Background reset
            bg = new Background();
            Object.keys(keys).forEach(k => keys[k] = false); // Reset Keys
        }

        function nextLevel() {
            floor++;
            document.getElementById('floor-num').innerText = floor;
            player.x = 100; player.y = GROUND_Y - 50;
            camera.x = 0;

            // Reset Level Entities
            enemies = []; drops = []; projectiles = []; platforms = []; spikes = []; texts = [];

            // Gen Platforms
            platforms.push({ x: 0, y: GROUND_Y, w: WORLD_WIDTH, h: 50, type: 'ground' });
            // Random Platforms
            for (let i = 0; i < 10; i++) {
                platforms.push({
                    x: Math.random() * (WORLD_WIDTH - 500) + 300,
                    y: GROUND_Y - Math.random() * 150 - 50,
                    w: Math.random() * 200 + 100, h: 20
                });
            }

            // Gen Enemies
            const count = 3 + floor * 1;
            let bossSpawned = false;

            // Boss Chance (Low)
            if (floor === 30) {
                showToast('âš ï¸ æœ€çµ‚å±¤ï¼šç«ç„°å·¨é¾ âš ï¸');
                enemies.push(new Dragon(WORLD_WIDTH - 400, GROUND_Y - 200));
                bossSpawned = true;
                return; // No other enemies
            }

            if (floor % 10 === 0) {
                const isTroll = Math.random() < 0.5;
                const bossX = WORLD_WIDTH - 300;
                enemies.push(isTroll ? new Troll(bossX, GROUND_Y) : new GiantSlime(bossX, GROUND_Y));
                bossSpawned = true;
                showToast('è­¦å‘Š: å¼·å¤§æ°£æ¯æ¥è¿‘ä¸­...');
            }

            for (let i = 0; i < count; i++) {
                if (bossSpawned && i > count / 2) break; // Reduce enemies if boss present

                const rx = Math.random() * (WORLD_WIDTH - 600) + 500;
                const r = Math.random();
                let e;
                if (r < 0.2) e = new Slime(rx, GROUND_Y);
                else if (r < 0.4) e = new Goblin(rx, GROUND_Y);
                else if (r < 0.6) e = new Skeleton(rx, GROUND_Y);
                else if (r < 0.8) e = new Orc(rx, GROUND_Y);
                else e = new Bat(rx, GROUND_Y - 100 - Math.random() * 100); // Bat in air
                enemies.push(e);
            }

            bg = new Background();
            document.getElementById('ui-event').style.display = 'none';
            document.getElementById('ui-shop').style.display = 'none';
            document.getElementById('boss-hp-container').style.display = 'none'; // Hide Boss Bar initially
            paused = false;

            if (player.hasTrait('curse_hunger')) { player.hp = 10; player.maxHp = 10; }
            if (player.hasTrait('bless_dawn')) { player.hp = Math.min(player.hp + 10, player.maxHp); showToast("ç ´æ›‰ç¥ç¦: +10HP"); }

            // Clear temp buffs
            player.tempAtk = 0;
            if (!player.hasTrait('bless_fort')) player.tempDef = 0;

            player.updateHealUI();
        }

        function showEventUI() {
            paused = true;
            document.getElementById('ui-event').style.display = 'flex';
            // Randomly hide Shop if unlucky? No, let's keep it constant for gameplay flow or 30% chance.
            document.getElementById('btn-shop').style.display = (Math.random() > 0.3) ? 'flex' : 'none';
        }

        function triggerEvent(type) {
            const r = Math.random();
            const modalContent = document.querySelector('#ui-event .modal-content');

            if (type === 'left' || type === 'right') {
                // Special Trait Events
                if (r < 0.3) {
                    // Get Random Blessing
                    const avail = TRAITS.blessings.filter(id => !player.hasTrait(id));
                    if (avail.length > 0) {
                        const pick = avail[Math.floor(Math.random() * avail.length)];
                        const trait = ITEMS[pick];
                        showConfirmDialog(
                            `ç¥åƒç™¼ç¾`,
                            `${trait.icon} ${trait.name}<br>${trait.desc}`,
                            `æ¥å—ç¥ç¦`,
                            () => {
                                player.traits.push(trait);
                                showToast(`ç²å¾—ç¥ç¦: ${trait.name}`);
                                nextLevel();
                            },
                            `é›¢é–‹`,
                            () => nextLevel()
                        );
                        return;
                    }
                } else if (r < 0.5) {
                    // Get Random Curse
                    const avail = TRAITS.curses.filter(id => !player.hasTrait(id));
                    if (avail.length > 0) {
                        const pick = avail[Math.floor(Math.random() * avail.length)];
                        const trait = ITEMS[pick];
                        showConfirmDialog(
                            `é‚ªç¥å‡è¦–`,
                            `${trait.icon} ${trait.name}<br>${trait.desc}`,
                            `æ¥å—è©›å’’`,
                            () => {
                                player.traits.push(trait);
                                showToast(`ç²å¾—è©›å’’: ${trait.name}`);
                                nextLevel();
                            },
                            `æ‹’çµ•`,
                            () => nextLevel()
                        );
                        return;
                    }
                }

                // Normal & New Events
                const evt = Math.random();

                // 1. é­é‡æ¶åŠ« (æ©Ÿç‡é™ä½)
                if (evt < 0.05) {
                    showToast('é­é‡æ¶åŠ«ï¼å¤±å»äº† 50 é‡‘å¹£'); player.gold = Math.max(0, player.gold - 50);
                    nextLevel();
                }
                // 2. è¸©åˆ°é™·é˜± (æ©Ÿç‡å¤§å¹…é™ä½)
                else if (evt < 0.1) {
                    showToast('è¸©åˆ°é™·é˜±ï¼ç”Ÿå‘½ -20'); player.hp -= 20; if (player.hp <= 0) endGame(false);
                    nextLevel();
                }
                // 3. ç™¼ç¾å¯¶ç®± (äº’å‹•äº‹ä»¶)
                else if (evt < 0.3) {
                    showConfirmDialog(
                        `ç™¼ç¾å¯¶ç®±`, `ä¸€å€‹ç¥ç§˜çš„å¯¶ç®±ï¼Œä¹Ÿè¨±æœ‰é™·é˜±...`,
                        `æ‰“é–‹ (70% æˆåŠŸ)`, () => {
                            if (Math.random() < 0.7) {
                                showToast('ç²å¾—å¼·åŠ›è—¥æ°´ï¼');
                                player.inventory.push(ITEMS.potion_l);
                            } else {
                                showToast('å¯¶ç®±é™·é˜±ï¼ç”Ÿå‘½ -30');
                                player.hp -= 30; if (player.hp <= 0) endGame(false);
                            }
                            nextLevel();
                        },
                        `é›¢é–‹`, () => nextLevel()
                    );
                }
                // 4. å†’éšªè€…æ±‚æ•‘ (äº’å‹•äº‹ä»¶)
                else if (evt < 0.5) {
                    showConfirmDialog(
                        `å—å‚·çš„å†’éšªè€…`, `å¥¹è¢«æ€ªç‰©åŒ…åœäº†ï¼è¦å¹«å¿™å—ï¼Ÿ`,
                        `æ‹¯æ•‘ (50% æˆåŠŸ)`, () => {
                            if (Math.random() < 0.5) {
                                showToast('æ‹¯æ•‘æˆåŠŸï¼ç²å¾—è´ˆç¦®');
                                player.inventory.push(ITEMS.goblin_sack);
                            } else {
                                showToast('æ‹¯æ•‘å¤±æ•—...å—å‚· 10');
                                player.hp -= 10; if (player.hp <= 0) endGame(false);
                            }
                            nextLevel();
                        },
                        `ç„¡è¦–`, () => nextLevel()
                    );
                }
                // 5. é‚ªæ•™å¾’ (äº’å‹•äº‹ä»¶)
                // 5. é‚ªæ•™å¾’ (äº’å‹•äº‹ä»¶) -> Changed to Forbidden Cult (High Risk)
                else if (evt < 0.55) {
                    showConfirmDialog(
                        `é‚ªæ•™ç¶æ¶`, `ä¸€ç¾¤ç‹‚ä¿¡å¾’å°‡ä½ åŒ…åœ...<br>å¼·åˆ¶æ³¨å…¥è©›å’’ä»¥æ›å–ç”Ÿå­˜ï¼Ÿ`,
                        `æ¥å— (ç²å¾—3å€‹è©›å’’)`, () => {
                            for (let i = 0; i < 3; i++) {
                                const pick = TRAITS.curses[Math.floor(Math.random() * TRAITS.curses.length)];
                                player.traits.push(ITEMS[pick]);
                            }
                            showToast(`èº«é«”è¢«è©›å’’ä¾µè•...`);
                            nextLevel();
                        },
                        `åæŠ— (HP -50)`, () => {
                            player.takeDamage(50);
                            showToast('ä½ æ®ºå‡ºä¸€æ¢è¡€è·¯...');
                            if (player.hp > 0) nextLevel();
                        }
                    );
                }
                // New: Forced Baptism
                else if (evt < 0.6) {
                    showConfirmDialog(
                        `å¼·åˆ¶å—æ´—`, `è¢«å¼·å…‰ç± ç½©ï¼Œç¥è–çš„åŠ›é‡çŒå…¥é«”å…§ï¼`,
                        `æ¥å— (ç²å¾—3å€‹ç¥ç¦)`, () => {
                            for (let i = 0; i < 3; i++) {
                                const pick = TRAITS.blessings[Math.floor(Math.random() * TRAITS.blessings.length)];
                                player.traits.push(ITEMS[pick]);
                            }
                            showToast(`ç²å¾—ç¥è–åŠ›é‡ï¼`);
                            nextLevel();
                        }
                    );
                }
                // 6. å“¥å¸ƒæ—è³½è·‘ (äº’å‹•äº‹ä»¶)
                else if (evt < 0.75) {
                    showConfirmDialog(
                        `å“¥å¸ƒæ—è³½è·‘`, `è¦è·Ÿå“¥å¸ƒæ—æ¯”é€Ÿåº¦å—ï¼Ÿ<br>è´äº†ç²å¾— 4 å€‹è¢‹å­ï¼`,
                        `æ¯”è³½`, () => {
                            if (Math.random() < 0.5) {
                                showToast('ä½ è´äº†ï¼ç²å¾—è±åšçå‹µ');
                                for (let i = 0; i < 4; i++) player.inventory.push(ITEMS.goblin_sack);
                            } else {
                                showToast('ä½ è¼¸äº†...ä»€éº¼éƒ½æ²’æ‹¿åˆ°');
                            }
                            nextLevel();
                        },
                        `æ²’èˆˆè¶£`, () => nextLevel()
                    );
                }
                // 7. å½©ç¥¨ (ç›´æ¥ç²å¾—)
                else if (evt < 0.85) {
                    showToast('åœ°ä¸Šæ’¿åˆ°å½©ç¥¨ï¼ç²å¾— 200 é‡‘å¹£');
                    player.gold += 200;
                    nextLevel();
                }
                // 8. å¹³å‡¡çš„å¯¶ç®± (ç›´æ¥ç²å¾—)
                else {
                    showToast('ç™¼ç¾å°å¯¶ç®±ï¼ç²å¾—è—¥æ°´');
                    player.inventory.push(ITEMS.potion_m);
                    nextLevel();
                }
            }
        }

        function showConfirmDialog(title, desc, btn1Text, btn1Action, btn2Text, btn2Action) {
            // Re-use event modal temporarily for choice
            const content = document.querySelector('#ui-event .modal-content');
            const originalHTML = content.innerHTML;

            content.innerHTML = `
                <h2>${title}</h2>
                <div style="font-size:20px; margin:20px;">${desc}</div>
                <div style="display:flex; gap:20px; justify-content:center;">
                    <button class="btn" id="confirm-btn1" style="font-size:24px; padding:10px 30px;">${btn1Text}</button>
                    ${btn2Text ? `<button class="btn" id="confirm-btn2" style="font-size:24px; padding:10px 30px;">${btn2Text}</button>` : ''}
                </div>
            `;

            document.getElementById('confirm-btn1').onclick = () => {
                content.innerHTML = originalHTML; // restore
                btn1Action();
            };
            if (btn2Text) {
                document.getElementById('confirm-btn2').onclick = () => {
                    content.innerHTML = originalHTML; // restore
                    btn2Action();
                };
            }
        }

        function openShop() {
            document.getElementById('ui-event').style.display = 'none';
            document.getElementById('ui-shop').style.display = 'flex';
            renderShop();
        }

        function renderShop() {
            document.getElementById('shop-gold').innerText = player.gold;
            // Buy List
            const buyDiv = document.getElementById('shop-buy-list');
            buyDiv.innerHTML = '';
            // New Weapons added to shop
            const wares = [
                ITEMS.potion_s, ITEMS.potion_m, ITEMS.potion_vio,
                ITEMS.dagger_curved, ITEMS.dagger_fast,
                ITEMS.sword, ITEMS.sword_iron,
                ITEMS.bow_wood, ITEMS.bow_recurve,
                ITEMS.leather, ITEMS.iron
            ];
            wares.forEach(item => {
                const d = document.createElement('div');
                d.className = 'shop-row';
                d.innerHTML = `<span style="display:flex; align-items:center; gap:5px;">${item.icon} ${item.name} <span style="color:gold; font-size:14px;">$${item.price || 50}</span></span> <button class="btn">è³¼è²·</button>`;
                d.querySelector('button').onclick = () => {
                    if (player.gold >= (item.price || 50)) {
                        player.gold -= (item.price || 50);
                        player.inventory.push(item);
                        alert('è³¼è²·æˆåŠŸ');
                        renderShop();
                    } else alert('é‡‘å¹£ä¸è¶³');
                };
                buyDiv.appendChild(d);
            });

            // Craft List
            const craftDiv = document.getElementById('shop-craft-list');
            craftDiv.innerHTML = '';

            // Quantity-based Recipes
            const recipes = [
                {
                    res: ITEMS.potion_l,
                    inputs: [{ item: ITEMS.potion_m, count: 2 }],
                    text: 'å¤§ç“¶è—¥æ°´ (éœ€ 2 ä¸­ç“¶)'
                },
                {
                    res: ITEMS.sword_poison,
                    inputs: [{ item: ITEMS.acid_goo, count: 30 }, { item: ITEMS.sword, count: 1 }],
                    text: 'æ¯’æ¶²éµåŠ (éœ€ 30 é»æ¶² + 1 å¤§åŠ)'
                },
                {
                    res: ITEMS.armor_iron_wing,
                    inputs: [{ item: ITEMS.bat_wing, count: 50 }, { item: ITEMS.skin, count: 20 }, { item: ITEMS.iron_ore, count: 10 }],
                    text: 'éµç¿¼é§ç”² (éœ€ 50 ç¿…è†€ + 20 ç¸çš® + 10 éµç¤¦)'
                }
            ];

            recipes.forEach(r => {
                const d = document.createElement('div');
                d.className = 'shop-row';
                d.innerHTML = `<span style="font-size:12px;">${r.text}</span> <button class="btn">åˆæˆ</button>`;

                d.querySelector('button').onclick = () => {
                    // Check Logic
                    const hasReq = r.inputs.every(req => {
                        const count = player.inventory.filter(i => i.id === req.item.id).length;
                        return count >= req.count;
                    });

                    if (hasReq) {
                        // Consume Logic
                        r.inputs.forEach(req => {
                            for (let i = 0; i < req.count; i++) {
                                const idx = player.inventory.findIndex(inv => inv.id === req.item.id);
                                if (idx !== -1) player.inventory.splice(idx, 1);
                            }
                        });

                        player.inventory.push(r.res);
                        alert('åˆæˆæˆåŠŸï¼');
                        renderShop();
                    } else alert('ç´ æä¸è¶³');
                };
                craftDiv.appendChild(d);
            });
        }

        function sellMaterials() {
            let gain = 0;
            for (let i = player.inventory.length - 1; i >= 0; i--) {
                if (player.inventory[i].type === 'mat') {
                    gain += player.inventory[i].price;
                    player.inventory.splice(i, 1);
                }
            }
            player.gold += gain;
            alert(`è³£å‡ºç´ æç²å¾— ${gain} é‡‘å¹£`);
            renderShop();
        }

        function endGame(win) { gameRunning = false; gameOver = true; const msg = document.getElementById('msg'); msg.style.display = 'block'; msg.innerHTML = win ? "WIN" : "<span style='color:red'>YOU DIED</span><br>Floor: " + floor; }

        let player = new Player(), bg = new Background();

        function loop() {
            if (paused) { requestAnimationFrame(loop); return; } // Pause loop

            if (!gameRunning) return; requestAnimationFrame(loop);
            if (hitStop > 0) { hitStop--; return; } frame++;
            let sx = 0, sy = 0; if (screenShake > 0) { sx = (Math.random() - 0.5) * screenShake; sy = (Math.random() - 0.5) * screenShake; screenShake *= 0.9; }

            // --- ç›¸æ©Ÿé‚è¼¯ ---
            let targetCamX = player.x - 400;
            targetCamX = Math.max(0, Math.min(WORLD_WIDTH - canvas.width, targetCamX));
            camera.x += (targetCamX - camera.x) * 0.1;

            // åˆ°é”çµ‚é»ï¼Œè§¸ç™¼äº‹ä»¶
            if (player.x > WORLD_WIDTH - 100) {
                showEventUI();
                player.x -= 50; // é˜²æ­¢é‡è¤‡è§¸ç™¼
            }

            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            bg.drawBack(ctx);

            ctx.save();
            ctx.translate(-camera.x + sx, 0 + sy);

            bg.drawWorld(ctx);

            particles.forEach(p => p.update()); particles = particles.filter(p => p.life > 0); particles.forEach(p => p.draw(ctx));

            // Drops
            drops.forEach(d => {
                ctx.font = '20px Arial'; ctx.fillText(d.item.icon, d.x, d.y);
                // Pick up
                if (Math.abs(player.x - d.x) < 40 && Math.abs(player.y - d.y) < 60) {
                    player.inventory.push(d.item);
                    d.picked = true;
                    // UI Tip
                    ctx.fillStyle = 'white'; ctx.fillText(`+${d.item.name}`, player.x, player.y - 50);
                }
            });
            drops = drops.filter(d => !d.picked);

            enemies.forEach(e => { e.update(); e.draw(ctx); });
            enemies = enemies.filter(e => e.hp > 0);

            player.update(); player.draw(ctx);

            projectiles.forEach(p => p.update()); projectiles = projectiles.filter(p => p.active); projectiles.forEach(p => p.draw(ctx));
            slashes.forEach(s => s.update()); slashes = slashes.filter(s => s.life > 0); slashes.forEach(s => s.draw(ctx));

            ctx.restore();
            bg.drawFront(ctx);
            ctx.restore();
        }
        ctx.fillStyle = 'white'; ctx.font = '20px Courier New';
        ctx.fillText("æŒ‰ æ”»æ“Šéµ(âš”) é–‹å§‹", canvas.width / 2 - 100, 300);
    </script>
</body>

</html>
```